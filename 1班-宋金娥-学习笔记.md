- [学习记录](#学习记录)
  - [1. 第一周通用技能学习](#1-第一周通用技能学习)
    - [1.1 git](#11-git)
    - [1.2 linux/ shell](#12-linux-shell)
      - [目录相关](#目录相关)
      - [磁盘管理](#磁盘管理)
      - [进程管理](#进程管理)
      - [shell 文件](#shell-文件)
    - [1.3 docker](#13-docker)
    - [1.4 mysql](#14-mysql)
    - [1.5 redis](#15-redis)
  - [2. Python 编程练习](#2-python-编程练习)
    - [2.1 列表（List）](#21-列表list)

# 学习记录
## 1. 第一周通用技能学习
### 1.1 git
![image](https://github.com/sje123456/2024_training/assets/71172395/794ff901-a44b-4c55-bd25-a31718fe8b5d)
| 作用 | 命令 | 备注 |
| ---- | ---- | ---- |
| 添加文件到暂存区 | git add | |
| 查看仓库当前的状态，显示有变更的文件 | git status | |
| 比较文件的不同，即暂存区和工作区的差异 | git diff | |
| 提交暂存区到本地仓库 | git commit | |
| 回退版本 | git reset | |
| 将文件从暂存区和工作区中删除 | git rm | |
| 移动或重命名工作区文件 | git mv ||
| 恢复或撤销文件的更改 | git restore | Git 2.23 版本引入 |
| 查看分支 | git branch| |
| 创建分支 |git branch (branchname)| | 
| 切换分支 |git checkout (branchname)| |
| 更清晰地切换分支 | git switch | Git 2.23 版本引入 | |
| 创建分支并切换 |  git checkout **-b** (branchname)| |
| 删除分支 | git branch -d (branchname) | |
| 分支合并 | git merge (branchname) | 将branchname 分支合并到当前分支；合并冲突需要手动修改|



### 1.2 linux/ shell
#### 目录相关
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `ls` | 列出目录及文件名 | `-l`: 长格式列表，显示文件的详细属性信息<br>`-a`: 列出所有文件，包括以`.`开头的隐藏文件<br>`-h`: 以人类可读的格式显示文件大小，如KB、MB | `ls -l`<br>`ls -a`<br>`ls -lh` |
| `cd` | 切换目录 | `-`: 返回到上一个目录<br>`~`: 切换到当前用户的主目录 | `cd -`<br>`cd ~` |
| `pwd` | 显示目前的目录 | `-P`: 显示实际路径，即物理路径<br>`-L`: 显示逻辑路径，即链接路径 | `pwd`<br>`pwd -P`<br>`pwd -L` |
| `mkdir` | 创建一个新的目录 | `-p`: 创建多级目录，若上级目录不存在则一并创建<br>`-m`: 设置新创建目录的权限 | `mkdir -p dir1/dir2`<br>`mkdir -m 755 new_directory` |
| `rmdir` | 删除一个空的目录 | (无) | `rmdir directory_name` |
| `cp` | 复制文件或目录 | `-r`: 递归复制目录及其子目录<br>`-p`: 保持源文件的属性，如权限和时间戳<br>`-v`: 显示复制的详细过程 | `cp -r dir1 dir2`<br>`cp -p file1 file2`<br>`cp -v file1 dir1` |
| `rm` | 删除文件或目录 | `-r`: 递归删除目录及其内容<br>`-f`: 强制删除，不提示确认<br>`-i`: 交互式删除，删除前提示确认 | `rm -r dir1`<br>`rm -f file1`<br>`rm -i file1` |
| `mv` | 移动文件与目录，或修改文件与目录的名称 | `-i`: 交互式操作，如果目标已存在则提示确认<br>`-n`: 不覆盖已存在的目标文件<br>`-v`: 显示移动或重命名过程的详细信息 | `mv -i file1 file2`<br>`mv -n file1 dir1`<br>`mv -v file1 dir1/file2` |
#### 磁盘管理
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `df` | 显示磁盘空间使用情况 | `-h`: 以人类可读的格式显示磁盘空间（如GB、MB）<br>`-T`: 显示文件系统的类型 | `df -h`<br>`df -T` |
| `du` | 显示目录或文件的磁盘使用情况 | `-h`: 以人类可读的格式显示大小<br>`-s`: 只显示总计的大小，不显示每个子目录的大小 | `du -h`<br>`du -sh /path/to/directory` |
| `fdisk` | 磁盘分区表管理 | `-l`: 列出所有磁盘的分区表信息 | `fdisk -l`<br>`fdisk /dev/sdb` 需要sudo|
| `mkfs` | 创建文件系统 | `-t`: 指定文件系统的类型（如ext4, xfs） | `mkfs -t ext4 /dev/sdb1` |
| `mount` | 挂载文件系统 | `-t`: 指定文件系统的类型<br>`-o`: 指定挂载选项 | `mount -t ext4 /dev/sdb1 /mount/point` |
| `umount` | 卸载挂载的文件系统 | 无 | `umount /mount/point` |
| `lsblk` | 列出所有可用磁盘及其分区 | `-f`: 显示文件系统类型 | `lsblk`<br>`lsblk -f` |
| `parted` | 磁盘分区和分区大小调整 | 无 | `parted /dev/sdb` |
| `pvcreate` | 创建物理卷（LVM） | 无 | `pvcreate /dev/sdb1` |
| `vgcreate` | 创建卷组（LVM） | 无 | `vgcreate my_volume_group /dev/sdb1` |
| `lvcreate` | 创建逻辑卷（LVM） | `-L`: 指定逻辑卷的大小<br>`-n`: 指定逻辑卷的名称 | `lvcreate -L 10G -n my_logical_volume my_volume_group` |
#### 进程管理
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `ps` | 显示当前进程的快照 | `-ef`: 显示所有进程，包括命令行参数<br>`-aux`: 显示所有进程，包括用户和CPU、内存使用情况 | `ps -ef`<br>`ps -aux` |
| `top` | 显示系统运行的进程 | `-u`: 显示指定用户的进程<br>`-p`: 显示指定PID的进程 | `top`<br>`top -u username`<br>`top -p PID` <br>默认按照CPU 使用率降序排列<br>按E 切换内存排序，<br> M 切换内存使用率排序 |
| `htop` | 一个更高级的进程查看器 | (通常不需要参数) | `htop` |
| `pgrep` | 搜索进程并列出匹配到的进程ID | `-u`: 列出指定用户的进程ID<br>`-l`: 显示进程名称 | `pgrep process_name`<br>`pgrep -u username`<br>`pgrep -l process_name` |
| `kill` | 发送信号到指定进程 | `-9`: 发送SIGKILL信号，强制结束进程 | `kill PID`<br>`kill -9 PID` |
| `pkill` | 根据名称杀死进程 | `-f`: 根据完整命令行杀死进程 | `pkill process_name`<br>`pkill -f process_name` |
| `renice` | 改变运行进程的优先级 | `new_niceness`: 新的优先级值 | `renice new_niceness PID` |
| `nohup` | 运行一个命令，忽略挂起信号 | `command`: 要运行的命令 | `nohup command &` |
| `nice` | 以指定的优先级运行命令 | `niceness`: 优先级值<br>`command`: 要运行的命令 | `nice -n niceness command` |  

**备注: 分析磁盘IO 还可用iotop <br>
        perf是Linux性能分析工具，可用pref命令分析CPU性能问题，可以识别哪些进程、函数或线程正在使用CPU资源**
#### shell 文件
```bash
##!/bin/bash
## 这是脚本的第一行，称为释伴（shebang），告诉系统应该使用哪个解释器来执行这个脚本。

## 定义变量
USERNAME="user"
PASSWORD="password123"

## 打印输出
echo "Hello, World!"

## 使用变量
echo "Username: $USERNAME"

## 条件判断
if [ "$USERNAME" == "admin" ]; then
    echo "Welcome, admin!"
elif [ "$USERNAME" == "user" ]; then
    echo "Welcome, user!"
else
    echo "Unknown user"
fi

## 循环
for i in {1..5}; do
    echo "Loop number: $i"
done

## 函数定义
function greet() {
    echo "Hello, $1!"
}

## 调用函数
greet "Alice"

## 接收命令行参数
echo "First command line argument: $1"

## 输出重定向
echo "This is an error message" >&2

## 执行命令并检查退出状态
ls -l /etc/passwd
if [ $? -eq 0 ]; then
    echo "Command succeeded"
else
    echo "Command failed"
fi

## 读取用户输入
read -p "Enter your name: " NAME
echo "Hello, $NAME!"

## 使用case语句
case "$USERNAME" in
    "admin")
        echo "You are an admin."
        ;;
    "user")
        echo "You are a regular user."
        ;;
    *)
        echo "Unknown user."
        ;;
esac

## 脚本结束
exit 0
```
- 特殊参数说明：
  
| 参数 | 说明 |
|------|------|
| `$##` | 传递到脚本的参数个数 |
| `$*` | 以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1$2 … $n"的形式输出所有参数。 |
| `$$` | 脚本运行的当前进程ID号 |
| `$!` | 后台运行的最后一个进程的ID号 |
| `$@` | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| `$-` | 显示Shell使用的当前选项，与`set`命令功能相同。 |
| `$?` | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。用于检查是否有误。 |
### 1.3 docker
docker 及 docker compose 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/91743bce-9f36-4a94-93c8-02385c7d1674)
![image](https://github.com/sje123456/2024_training/assets/71172395/dfc210b7-7fbe-4d2e-92a1-9f18dbe3aa3b)
![image](https://github.com/sje123456/2024_training/assets/71172395/348d621b-916d-4b9f-8043-fe33e24cf54a)

docker-compose  是用来定义和运行多容器docker 应用程序的工具，能够在docker节点上，以单引擎模式进行多容器应用的部署和管理。
compose 使用yaml 文件来定义多容器之间的关系（配置应用程序所需的所有服务），然后通过docker-compose up 命令执行一个yaml 文件，就可以从yml 文件配置中创阿金并启动所有服务，把完整的应用跑起来。
本质上。compose 把yaml 文件解析成docker 命令的参数，然后调用相应的docker命令行接口，基于docker API 完成应用的部署，从而将应用以容器化的方式管理起来。

| 命令 | 功能描述 | 使用示例 |
|------|-----------|----------|
| `docker-compose up` | 启动或重启服务 | `docker-compose up` |
| `docker-compose down` | 停止所有服务并移除容器、网络和数据卷 | `docker-compose down` |
| `docker-compose stop` | 停止所有服务 | `docker-compose stop` |
| `docker-compose start` | 启动所有服务 | `docker-compose start` |
| `docker-compose restart` | 重启所有服务 | `docker-compose restart` |
| `docker-compose ps` | 列出服务及其状态 | `docker-compose ps` |
| `docker-compose logs` | 查看服务的日志输出 | `docker-compose logs service_name` |
| `docker-compose exec` | 在服务容器中执行命令 | `docker-compose exec service_name command` |
| `docker-compose scale` | 更改服务容器的数量 | `docker-compose scale service_name=2` |
| `docker-compose kill` | 停止服务容器 | `docker-compose kill service_name` |
| `docker-compose pull` | 拉取服务依赖的镜像 | `docker-compose pull service_name` |
| `docker-compose build` | 构建或重新构建服务镜像 | `docker-compose build service_name` |
| `docker-compose config` | 验证Compose文件中的配置 | `docker-compose config` |
| `docker-compose create` | 创建服务容器但不启动 | `docker-compose create service_name` |
| `docker-compose run` | 一次性运行服务 | `docker-compose run service_name command` |

### 1.4 mysql
mysql 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/465ec0c3-f51f-40d6-a55b-22f039d781a1)
修改权限

![image](https://github.com/sje123456/2024_training/assets/71172395/6cd8acb4-31d0-4065-af79-9049ff956348)

创建库表、增删改查示例

![image](https://github.com/sje123456/2024_training/assets/71172395/c1436be0-fd8e-450a-a759-19dc05d845f8)
### 1.5 redis
redis 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/d136d677-2322-49a6-ad4f-ec05667ff756)

增删改查示例

![image](https://github.com/sje123456/2024_training/assets/71172395/a9bf0577-5d45-44be-a2f2-0a6bcb2ec860)

 
## 2. Python 编程练习
### 2.1 列表（List）

 基本特性

1. **定义**  
   列表是由逗号分隔的元素组成的，元素之间可以包含空格。

   示例：`my_list = [1, 2, 3, 4, 5]`

2. **索引和切片**

   列表中的每个元素都有一个索引，从0开始。

   使用索引来访问或修改列表中的元素。

   示例：`my_list[0]` 访问第一个元素，`my_list[2:4]` 获取第三个和第四个元素。

3. **添加元素**

   使用 `append()` 方法在列表末尾添加一个元素。

   使用 `insert()` 方法在指定索引处添加一个元素。


4. **删除元素**

   使用 `pop()` 方法删除指定索引处的元素。

   使用 `remove()` 方法删除指定元素。


5. **修改元素**

   直接通过索引来修改元素值。


6. **遍历列表**

   使用 `for` 循环来遍历列表中的每个元素。

7. **列表推导式**

   列表推导式是一种创建列表的快捷方式。
   示例：`squares = [x**2 for x in range(5)]`

8. **列表方法**

   - `len()`：获取列表的长度。
   - `reverse()`：反转列表元素的排列顺序。
   - `sort()`：对列表进行排序。
   - `sorted()`：返回一个新的排序列表，不修改原列表。
   - `index()`：返回列表中指定元素的索引。
   - `count()`：返回列表中指定元素的次数。

9. **列表的嵌套**

   列表可以包含其他列表，形成列表的嵌套。

10. **列表和字符串的区别**

    列表是可变的数据类型，可以修改和添加元素。
    字符串是不可变的，一旦创建就不能修改。


11. **列表的合并**
   - 使用 `+` 运算符将两个列表合并：`list1 = [1, 2, 3]; list2 = [4, 5, 6]; combined_list = list1 + list2`
   - 使用 `extend()` 方法将一个列表的元素添加到另一个列表中：`list1.extend(list2)`

12. **列表的复制**
   - 使用 `copy()` 方法创建列表的浅拷贝：`copied_list = original_list.copy()`
   - 使用切片操作创建列表的深拷贝：`copied_list = original_list[:]`

13. **列表的排序和反排序**
   - 使用 `sort()` 方法对列表进行升序排序：`my_list.sort()`
   - 使用 `reverse()` 方法反转列表的顺序：`my_list.reverse()`
   - 使用 `sorted()` 函数返回一个新的升序排序列表：`sorted_list = sorted(my_list)`

14. **列表的过滤**
   - 使用列表推导式过滤列表中的元素：`even_numbers = [x for x in my_list if x % 2 == 0]`
   - 使用 `filter()` 函数过滤列表中的元素：`odd_numbers = filter(lambda x: x % 2 != 0, my_list)`

15. **列表的映射**
   - 使用列表推导式将函数应用于列表中的每个元素：`squared_numbers = [x**2 for x in my_list]`
   - 使用 `map()` 函数将函数应用于列表中的每个元素：`squared_numbers = list(map(lambda x: x**2, my_list))`
16. 列表（List）和元组（Tuple）的打印技巧

 列表的打印技巧
- **列表合并**：使用 `+` 运算符或 `extend()` 方法合并列表。
- **列表复制**：使用 `copy()` 方法创建浅拷贝，或使用切片操作创建深拷贝。
- **列表排序和反排序**：使用 `sort()` 方法进行升序排序，`reverse()` 方法进行反序排序，或 `sorted()` 函数返回一个新的排序列表。
- **列表过滤**：使用列表推导式或 `filter()` 函数过滤列表中的元素。
- **列表映射**：使用列表推导式或 `map()` 函数将函数应用于列表中的每个元素。

1.  数字相关列表
- **列表推导式生成数字列表**：例如，生成1到10的立方列表。
- **列表方法处理数字列表**：例如，使用 `min()` 和 `max()` 方法核实列表是否从1开始到100万结束，使用 `sum()` 方法计算列表中所有数的总和。

1.  元组（Tuple）
- **元组是不可变的**：一旦创建，就不能修改。
- **元组的打印**：使用 `for` 循环遍历元组中的每个元素。
- **元组的切片**：无法对元组进行切片，因为元组是不可变的。

- **总结**

(1)**列表**：可变的数据类型，可以修改和添加元素。

(2)**元组**：不可变的数据类型，一旦创建就不能修改。

(3)**列表和元组的使用**：可以根据需要选择使用列表或元组。
