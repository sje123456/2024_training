
- [学习记录](#学习记录)
  - [1. 第一周通用技能学习](#1-第一周通用技能学习)
    - [1.1 git](#11-git)
    - [1.2 linux/ shell](#12-linux-shell)
      - [目录相关](#目录相关)
      - [磁盘管理](#磁盘管理)
      - [进程管理](#进程管理)
      - [shell 文件](#shell-文件)
    - [1.3 docker](#13-docker)
    - [1.4 mysql](#14-mysql)
    - [1.5 redis](#15-redis)
  - [2. Python 编程练习](#2-python-编程练习)
    - [2.1 列表（List）](#21-列表list)
    - [2.2 条件语句](#22-条件语句)
    - [2.3 字典](#23-字典)
    - [2.4 用户输入和while 循环](#24-用户输入和while-循环)
    - [2.5 函数](#25-函数)
    - [2.6 类](#26-类)
    - [2.7 文件和异常](#27-文件和异常)
      - [文件操作](#文件操作)
      - [异常](#异常)
    - [2.8 测试](#28-测试)
  - [3. 第三周python编程练习](#3-第三周python编程练习)
    - [3.1 SQLArchemy](#31-sqlarchemy)
    - [3.2 多线程](#32-多线程)
    - [3.3 redis](#33-redis)
  - [4. 第四周 自动驾驶数据加工与清洗](#4-第四周-自动驾驶数据加工与清洗)
    - [4.1 下载数据](#41-下载数据)
    - [4.2 数据清洗-存储](#42-数据清洗-存储)
      - [4.2.1. 数据清洗](#421-数据清洗)
      - [4.2.2. 数据存储](#422-数据存储)
        - [4.2.2.1 **数据类型**](#4221-数据类型)
        - [4.2.2.2 **单表存储 or 多表关联**](#4222-单表存储-or-多表关联)
        - [4.2.2.3 **session 与 线程安全**](#4223-session-与-线程安全)
    - [4.3 数据应用](#43-数据应用)
      - [4.3.1 FastAPI](#431-fastapi)
      - [4.3.2 Pydantic 模型](#432-pydantic-模型)
      - [4.3.3 响应模型](#433-响应模型)
      - [4.3.3 静态资源下载](#433-静态资源下载)

# 学习记录
## 1. 第一周通用技能学习
### 1.1 git
![image](https://github.com/sje123456/2024_training/assets/71172395/794ff901-a44b-4c55-bd25-a31718fe8b5d)
| 作用 | 命令 | 备注 |
| ---- | ---- | ---- |
| 添加文件到暂存区 | git add | |
| 查看仓库当前的状态，显示有变更的文件 | git status | |
| 比较文件的不同，即暂存区和工作区的差异 | git diff | |
| 提交暂存区到本地仓库 | git commit | |
| 回退版本 | git reset | |
| 将文件从暂存区和工作区中删除 | git rm | |
| 移动或重命名工作区文件 | git mv ||
| 恢复或撤销文件的更改 | git restore | Git 2.23 版本引入 |
| 查看分支 | git branch| |
| 创建分支 |git branch (branchname)| | 
| 切换分支 |git checkout (branchname)| |
| 更清晰地切换分支 | git switch | Git 2.23 版本引入 | |
| 创建分支并切换 |  git checkout **-b** (branchname)| |
| 删除分支 | git branch -d (branchname) | |
| 分支合并 | git merge (branchname) | 将branchname 分支合并到当前分支；合并冲突需要手动修改|



### 1.2 linux/ shell
#### 目录相关
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `ls` | 列出目录及文件名 | `-l`: 长格式列表，显示文件的详细属性信息<br>`-a`: 列出所有文件，包括以`.`开头的隐藏文件<br>`-h`: 以人类可读的格式显示文件大小，如KB、MB | `ls -l`<br>`ls -a`<br>`ls -lh` |
| `cd` | 切换目录 | `-`: 返回到上一个目录<br>`~`: 切换到当前用户的主目录 | `cd -`<br>`cd ~` |
| `pwd` | 显示目前的目录 | `-P`: 显示实际路径，即物理路径<br>`-L`: 显示逻辑路径，即链接路径 | `pwd`<br>`pwd -P`<br>`pwd -L` |
| `mkdir` | 创建一个新的目录 | `-p`: 创建多级目录，若上级目录不存在则一并创建<br>`-m`: 设置新创建目录的权限 | `mkdir -p dir1/dir2`<br>`mkdir -m 755 new_directory` |
| `rmdir` | 删除一个空的目录 | (无) | `rmdir directory_name` |
| `cp` | 复制文件或目录 | `-r`: 递归复制目录及其子目录<br>`-p`: 保持源文件的属性，如权限和时间戳<br>`-v`: 显示复制的详细过程 | `cp -r dir1 dir2`<br>`cp -p file1 file2`<br>`cp -v file1 dir1` |
| `rm` | 删除文件或目录 | `-r`: 递归删除目录及其内容<br>`-f`: 强制删除，不提示确认<br>`-i`: 交互式删除，删除前提示确认 | `rm -r dir1`<br>`rm -f file1`<br>`rm -i file1` |
| `mv` | 移动文件与目录，或修改文件与目录的名称 | `-i`: 交互式操作，如果目标已存在则提示确认<br>`-n`: 不覆盖已存在的目标文件<br>`-v`: 显示移动或重命名过程的详细信息 | `mv -i file1 file2`<br>`mv -n file1 dir1`<br>`mv -v file1 dir1/file2` |
#### 磁盘管理
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `df` | 显示磁盘空间使用情况 | `-h`: 以人类可读的格式显示磁盘空间（如GB、MB）<br>`-T`: 显示文件系统的类型 | `df -h`<br>`df -T` |
| `du` | 显示目录或文件的磁盘使用情况 | `-h`: 以人类可读的格式显示大小<br>`-s`: 只显示总计的大小，不显示每个子目录的大小 | `du -h`<br>`du -sh /path/to/directory` |
| `fdisk` | 磁盘分区表管理 | `-l`: 列出所有磁盘的分区表信息 | `fdisk -l`<br>`fdisk /dev/sdb` 需要sudo|
| `mkfs` | 创建文件系统 | `-t`: 指定文件系统的类型（如ext4, xfs） | `mkfs -t ext4 /dev/sdb1` |
| `mount` | 挂载文件系统 | `-t`: 指定文件系统的类型<br>`-o`: 指定挂载选项 | `mount -t ext4 /dev/sdb1 /mount/point` |
| `umount` | 卸载挂载的文件系统 | 无 | `umount /mount/point` |
| `lsblk` | 列出所有可用磁盘及其分区 | `-f`: 显示文件系统类型 | `lsblk`<br>`lsblk -f` |
| `parted` | 磁盘分区和分区大小调整 | 无 | `parted /dev/sdb` |
| `pvcreate` | 创建物理卷（LVM） | 无 | `pvcreate /dev/sdb1` |
| `vgcreate` | 创建卷组（LVM） | 无 | `vgcreate my_volume_group /dev/sdb1` |
| `lvcreate` | 创建逻辑卷（LVM） | `-L`: 指定逻辑卷的大小<br>`-n`: 指定逻辑卷的名称 | `lvcreate -L 10G -n my_logical_volume my_volume_group` |
#### 进程管理
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `ps` | 显示当前进程的快照 | `-ef`: 显示所有进程，包括命令行参数<br>`-aux`: 显示所有进程，包括用户和CPU、内存使用情况 | `ps -ef`<br>`ps -aux` |
| `top` | 显示系统运行的进程 | `-u`: 显示指定用户的进程<br>`-p`: 显示指定PID的进程 | `top`<br>`top -u username`<br>`top -p PID` <br>默认按照CPU 使用率降序排列<br>按E 切换内存排序，<br> M 切换内存使用率排序 |
| `htop` | 一个更高级的进程查看器 | (通常不需要参数) | `htop` |
| `pgrep` | 搜索进程并列出匹配到的进程ID | `-u`: 列出指定用户的进程ID<br>`-l`: 显示进程名称 | `pgrep process_name`<br>`pgrep -u username`<br>`pgrep -l process_name` |
| `kill` | 发送信号到指定进程 | `-9`: 发送SIGKILL信号，强制结束进程 | `kill PID`<br>`kill -9 PID` |
| `pkill` | 根据名称杀死进程 | `-f`: 根据完整命令行杀死进程 | `pkill process_name`<br>`pkill -f process_name` |
| `renice` | 改变运行进程的优先级 | `new_niceness`: 新的优先级值 | `renice new_niceness PID` |
| `nohup` | 运行一个命令，忽略挂起信号 | `command`: 要运行的命令 | `nohup command &` |
| `nice` | 以指定的优先级运行命令 | `niceness`: 优先级值<br>`command`: 要运行的命令 | `nice -n niceness command` |  

**备注: 分析磁盘IO 还可用iotop <br>
        perf是Linux性能分析工具，可用pref命令分析CPU性能问题，可以识别哪些进程、函数或线程正在使用CPU资源**
#### shell 文件
```bash
##!/bin/bash
## 这是脚本的第一行，称为释伴（shebang），告诉系统应该使用哪个解释器来执行这个脚本。

## 定义变量
USERNAME="user"
PASSWORD="password123"

## 打印输出
echo "Hello, World!"

## 使用变量
echo "Username: $USERNAME"

## 条件判断
if [ "$USERNAME" == "admin" ]; then
    echo "Welcome, admin!"
elif [ "$USERNAME" == "user" ]; then
    echo "Welcome, user!"
else
    echo "Unknown user"
fi

## 循环
for i in {1..5}; do
    echo "Loop number: $i"
done

## 函数定义
function greet() {
    echo "Hello, $1!"
}

## 调用函数
greet "Alice"

## 接收命令行参数
echo "First command line argument: $1"

## 输出重定向
echo "This is an error message" >&2

## 执行命令并检查退出状态
ls -l /etc/passwd
if [ $? -eq 0 ]; then
    echo "Command succeeded"
else
    echo "Command failed"
fi

## 读取用户输入
read -p "Enter your name: " NAME
echo "Hello, $NAME!"

## 使用case语句
case "$USERNAME" in
    "admin")
        echo "You are an admin."
        ;;
    "user")
        echo "You are a regular user."
        ;;
    *)
        echo "Unknown user."
        ;;
esac

## 脚本结束
exit 0
```
- 特殊参数说明：
  
| 参数 | 说明 |
|------|------|
| `$##` | 传递到脚本的参数个数 |
| `$*` | 以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1$2 … $n"的形式输出所有参数。 |
| `$$` | 脚本运行的当前进程ID号 |
| `$!` | 后台运行的最后一个进程的ID号 |
| `$@` | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| `$-` | 显示Shell使用的当前选项，与`set`命令功能相同。 |
| `$?` | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。用于检查是否有误。 |
### 1.3 docker
docker 及 docker compose 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/91743bce-9f36-4a94-93c8-02385c7d1674)
![image](https://github.com/sje123456/2024_training/assets/71172395/dfc210b7-7fbe-4d2e-92a1-9f18dbe3aa3b)
![image](https://github.com/sje123456/2024_training/assets/71172395/348d621b-916d-4b9f-8043-fe33e24cf54a)

docker-compose  是用来定义和运行多容器docker 应用程序的工具，能够在docker节点上，以单引擎模式进行多容器应用的部署和管理。
compose 使用yaml 文件来定义多容器之间的关系（配置应用程序所需的所有服务），然后通过docker-compose up 命令执行一个yaml 文件，就可以从yml 文件配置中创阿金并启动所有服务，把完整的应用跑起来。
本质上。compose 把yaml 文件解析成docker 命令的参数，然后调用相应的docker命令行接口，基于docker API 完成应用的部署，从而将应用以容器化的方式管理起来。

| 命令 | 功能描述 | 使用示例 |
|------|-----------|----------|
| `docker-compose up` | 启动或重启服务 | `docker-compose up` |
| `docker-compose down` | 停止所有服务并移除容器、网络和数据卷 | `docker-compose down` |
| `docker-compose stop` | 停止所有服务 | `docker-compose stop` |
| `docker-compose start` | 启动所有服务 | `docker-compose start` |
| `docker-compose restart` | 重启所有服务 | `docker-compose restart` |
| `docker-compose ps` | 列出服务及其状态 | `docker-compose ps` |
| `docker-compose logs` | 查看服务的日志输出 | `docker-compose logs service_name` |
| `docker-compose exec` | 在服务容器中执行命令 | `docker-compose exec service_name command` |
| `docker-compose scale` | 更改服务容器的数量 | `docker-compose scale service_name=2` |
| `docker-compose kill` | 停止服务容器 | `docker-compose kill service_name` |
| `docker-compose pull` | 拉取服务依赖的镜像 | `docker-compose pull service_name` |
| `docker-compose build` | 构建或重新构建服务镜像 | `docker-compose build service_name` |
| `docker-compose config` | 验证Compose文件中的配置 | `docker-compose config` |
| `docker-compose create` | 创建服务容器但不启动 | `docker-compose create service_name` |
| `docker-compose run` | 一次性运行服务 | `docker-compose run service_name command` |

### 1.4 mysql
mysql 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/465ec0c3-f51f-40d6-a55b-22f039d781a1)
修改权限

![image](https://github.com/sje123456/2024_training/assets/71172395/6cd8acb4-31d0-4065-af79-9049ff956348)

创建库表、增删改查示例

![image](https://github.com/sje123456/2024_training/assets/71172395/c1436be0-fd8e-450a-a759-19dc05d845f8)
### 1.5 redis
redis 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/d136d677-2322-49a6-ad4f-ec05667ff756)

增删改查示例

![image](https://github.com/sje123456/2024_training/assets/71172395/a9bf0577-5d45-44be-a2f2-0a6bcb2ec860)

 
## 2. Python 编程练习
### 2.1 列表（List）

 基本特性

1. **定义**  
   列表是由逗号分隔的元素组成的，元素之间可以包含空格。

   示例：`my_list = [1, 2, 3, 4, 5]`

2. **索引和切片**

   列表中的每个元素都有一个索引，从0开始。

   使用索引来访问或修改列表中的元素。

   示例：`my_list[0]` 访问第一个元素，`my_list[2:4]` 获取第三个和第四个元素。

3. **添加元素**

   使用 `append()` 方法在列表末尾添加一个元素。

   使用 `insert()` 方法在指定索引处添加一个元素。


4. **删除元素**

   使用 `pop()` 方法删除指定索引处的元素。

   使用 `remove()` 方法删除指定元素。


5. **修改元素**

   直接通过索引来修改元素值。


6. **遍历列表**

   使用 `for` 循环来遍历列表中的每个元素。

7. **列表推导式**

   列表推导式是一种创建列表的快捷方式。
   示例：`squares = [x**2 for x in range(5)]`

8. **列表方法**

   - `len()`：获取列表的长度。
   - `reverse()`：反转列表元素的排列顺序。
   - `sort()`：对列表进行排序。
   - `sorted()`：返回一个新的排序列表，不修改原列表。
   - `index()`：返回列表中指定元素的索引。
   - `count()`：返回列表中指定元素的次数。

9. **列表的嵌套**

   列表可以包含其他列表，形成列表的嵌套。

10. **列表和字符串的区别**

    列表是可变的数据类型，可以修改和添加元素。
    字符串是不可变的，一旦创建就不能修改。


11. **列表的合并**
   - 使用 `+` 运算符将两个列表合并：`list1 = [1, 2, 3]; list2 = [4, 5, 6]; combined_list = list1 + list2`
   - 使用 `extend()` 方法将一个列表的元素添加到另一个列表中：`list1.extend(list2)`

12. **列表的复制**
   - 使用 `copy()` 方法创建列表的浅拷贝：`copied_list = original_list.copy()`
   - 使用切片操作创建列表的深拷贝：`copied_list = original_list[:]`

13. **列表的排序和反排序**
   - 使用 `sort()` 方法对列表进行升序排序：`my_list.sort()`
   - 使用 `reverse()` 方法反转列表的顺序：`my_list.reverse()`
   - 使用 `sorted()` 临时排序，函数返回一个新的升序排序列表：`sorted_list = sorted(my_list)`

14. **列表的过滤**
   - 使用列表推导式过滤列表中的元素：`even_numbers = [x for x in my_list if x % 2 == 0]`
   - 使用 `filter()` 函数过滤列表中的元素：`odd_numbers = filter(lambda x: x % 2 != 0, my_list)`

15. **列表的映射**
   - 使用列表推导式将函数应用于列表中的每个元素：`squared_numbers = [x**2 for x in my_list]`
   - 使用 `map()` 函数将函数应用于列表中的每个元素：`squared_numbers = list(map(lambda x: x**2, my_list))`
16. 列表（List）和元组（Tuple）的打印技巧


17. 元组（Tuple）
- **元组是不可变的**：一旦创建，就不能修改。
- **元组的打印**：使用 `for` 循环遍历元组中的每个元素。
- **元组的切片**：无法对元组进行切片，因为元组是不可变的。
- **总结**
(1)**列表**：可变的数据类型，可以修改和添加元素。

(2)**元组**：不可变的数据类型，一旦创建就不能修改。

(3)**列表和元组的使用**：可以根据需要选择使用列表或元组。
### 2.2 条件语句
```python
if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
```
### 2.3 字典
字典是另一种可变容器模型，且可存储任意类型对象。  
字典的每个键值 key=>value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：    
d = {key1 : value1, key2 : value2, key3 : value3 }  
- 创建空字典
(1)使用大括号 { } 创建空字典：`emptyDict = {}`
(2)使用内建函数 dict() 创建字典：
`emptyDict = dict()`
- 访问字典
```python
alien_0 = {'color': 'green', 'points': 5}
new_points = alien_0['points']
```
- 添加\修改键值对
 ```python
 alien_0['x_position'] = 0
```
修改不存在的键值对会报keyError
- 删除键值对
```python
  del alien_0['points']
```
- get() 访问
```python
# get() ⽅法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不存在时要返回的值，是可选的：
alien_0 = {'color': 'green', 'speed': 'slow'}
point_value = alien_0.get('points', 'No point value assigned.')
print(point_value)
```
- 字典的遍历
```python
user_0 = {
 'username': 'efermi',
 'first': 'enrico',
 'last': 'fermi',
 }
for key, value in user_0.items():
   print(f"\nKey: {key}")
   print(f"Value: {value}")
```
-  遍历所有键
`keys()`
- 遍历所有值
`values()`
- 字典嵌套
  （1）字典列表
  （2）字典中存储列表
```
pizza = {
 'crust': 'thick',
 'toppings': ['mushrooms', 'extra cheese'],
 }
 # 概述顾客点的⽐萨
print(f"You ordered a {pizza['crust']}-crust pizza "
   "with the following toppings:")
for topping in pizza['toppings']:
   print(f"\t{topping}")
  
```
  （3）字典中存储字典
```python
 users = {
 'aeinstein': {
 'first': 'albert',
 'last': 'einstein',
 'location': 'princeton',
 },
 'mcurie': {
 'first': 'marie',
 'last': 'curie',
 'location': 'paris',
 },
 }
for username, user_info in users.items():
   print(f"\nUsername: {username}")
   full_name = f"{user_info['first']} {user_info['last']}"
   location = user_info['location']
   print(f"\tFull name: {full_name.title()}")
   print(f"\tLocation: {location.title()}")
```
### 2.4 用户输入和while 循环
- input()
默认输入是字符串，使用int() 转换成数值
- while 循环与退出
  (1)输入特定值
```python
prompt = "\nTell me something, and I will repeat it back to you:"
prompt += "\nEnter 'quit' to end the program. "
message = ""
while message != 'quit':
 message = input(prompt)
 print(message)
```
（2）使用标志
```python
prompt = "\nTell me something, and I will repeat it back to you:"
prompt += "\nEnter 'quit' to end the program. "
active = True
while active:
   message = input(prompt)
   if message == 'quit':
      active = False
   else:
      print(message)
```
(3)使用break
```python
prompt = "\nPlease enter the name of a city you have visited:"
prompt += "\n(Enter 'quit' when you are finished.) "
while True:
   city = input(prompt)
   if city == 'quit':
      break
   else:
      print(f"I'd love to go to {city.title()}!")
```
(4)使用continue
```python
current_number = 0
while current_number < 10:
   current_number += 1
   if current_number % 2 == 0:
      continue
   print(current_number)
```
### 2.5 函数
**- Python 函数定义与使用**
函数是 Python 中组织代码的基本单位，它允许我们定义可重复使用的代码块来执行特定的任务。函数通过 def 关键字来定义，后跟函数名和括号内的参数列表。函数体是缩进的代码块。
```python
def greet(name):
    """打印问候语"""
    print(f"Hello, {name}!")

greet("Alice")  # 调用函数，输出: Hello, Alice!
```
**- 返回值**
函数可以使用 return 语句来返回一个值给调用者。如果没有 return 语句，函数会默认返回 None。
```python
def add(a, b):
    """返回两个数的和"""
    return a + b

result = add(3, 4)  # 调用函数，result 的值为 7
```
**- 参数传递**
Python 中的参数传递涉及到几个概念：位置参数、关键字参数、默认参数、不定长参数。

**(1) 位置参数**
位置参数是最常见的参数类型，调用函数时按照定义的顺序传递。
```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('hamster', 'harry')  # 位置参数传递
```

**(2) 关键字参数**
关键字参数允许你在调用函数时指定参数名，这样可以不按顺序传递参数。
```python
describe_pet(pet_name='harry', animal_type='hamster')  # 关键字参数传递
```
**(3) 默认参数**
在定义函数时，可以为参数设置默认值。如果调用函数时没有提供相应的参数，则使用默认值。
```python
def describe_pet(pet_name, animal_type='dog'):
    """显示宠物的信息，默认动物类型为狗"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name='willie')  # 使用默认参数，输出: I have a dog. My dog's name is Willie.
```
**(4)不定长参数**
有时候你可能需要一个函数能够处理任意数量的参数。这些参数可以通过 *args 和 **kwargs 来接收。

*args 用于传递任意数量的位置参数，这些参数会被打包成一个元组。
**kwargs 用于传递任意数量的关键字参数，这些参数会被打包成一个字典。
```python
def make_pizza(*toppings):
    """打印顾客点的所有配料"""
    print(toppings)

make_pizza('pepperoni')  # 输出: ('pepperoni',)
make_pizza('mushrooms', 'green peppers', 'extra cheese')  # 输出: ('mushrooms', 'green peppers', 'extra cheese')
def build_profile(first, last, **user_info):
    """创建一个字典，其中包含我们知道的用户信息"""
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 'einstein', location='princeton', field='physics')
```
**参数传递的要点**
1. Python 中的参数传递是对象引用的传递，对于不可变数据类型（如整数、字符串、元组），函数内部的操作不会影响原始数据。
2. 对于可变数据类型（如列表、字典），函数内部的操作会影响原始数据。
3. 默认参数的值只在函数定义时计算一次，因此如果默认参数是一个可变数据类型，可能会引起意外的行为。
4. 使用 *args 和 **kwargs 时，函数可以接受任意数量的参数，这使得函数更加灵活，但也可能导致代码的可读性降低。
### 2.6 类

Python 是一种面向对象的编程语言。在 Python 中，几乎所有的东西都是对象，拥有属性和方法。类（Class）是用于创建对象的蓝图或原型。类定义了一组属性（称为成员变量）和方法（称为成员函数）。

1. 类的定义

类使用 `class` 关键字来定义。类名通常采用大写字母开头的驼峰命名法。类定义后跟一个冒号，然后是类的主体，一个缩进的代码块。

```python
class MyClass:
    """这是一个简单的类示例"""
    def __init__(self, name, age):
        self.name = name  # 实例变量
        self.age = age    # 实例变量

    def display(self):
        """一个成员函数，显示实例变量"""
        print(f"Name: {self.name}, Age: {self.age}")
```
2. 创建对象
创建类的实例（对象）非常简单，只需要在类名后加上括号。

```python
# 创建 MyClass 的一个对象
obj = MyClass("Alice", 30)

# 调用对象的 display 方法
obj.display()  # 输出: Name: Alice, Age: 30
```
3. 构造函数 __init__
__init__ 方法是一个特殊的方法，当创建类的新实例时会自动调用。这个方法内的 self 参数代表类的实例本身。
4. 成员变量
成员变量是类中定义的变量，用于存储每个对象的状态。成员变量通常在 __init__ 方法中通过 self 关键字来创建。
5. 成员函数
成员函数是类中定义的函数，用于对象可以执行的操作。成员函数至少有一个参数，通常是 self，代表类的实例
6. 类的方法类型
- 实例方法：第一个参数是 self，操作对象实例的属性。
- 类方法：使用 @classmethod 装饰器，第一个参数是 cls，操作类级别的属性。
- 静态方法：使用 @staticmethod 装饰器，不需要特定参数，操作类或实例的属性
```python
class MyClass:
    class_variable = "I'm a class variable"

    def __init__(self, name):
        self.name = name

    def instance_method(self):
        return f"Hello, {self.name}"

    @classmethod
    def class_method(cls):
        return f"Class variable: {cls.class_variable}"

    @staticmethod
    def static_method():
        return "I'm a static method"
```
7. 继承
继承是面向对象编程的一个主要特性。它允许我们定义一个类（子类）来继承另一个类（父类）的属性和方法。
```python
class Parent:
    def show(self):
        print("Parent method called")

class Child(Parent):
    def show(self):
        print("Child method called")

child = Child()
child.show()  # 输出: Child method called

```
8. 多态
多态是指同一个方法在不同类型的对象上执行时，表现出不同的行为。在 Python 中，多态是天然支持的。
```python
class Dog:
    def sound(self):
        return "Bark"

class Cat:
    def sound(self):
        return "Meow"

def animal_sound(animal):
    print(animal.sound())

dog = Dog()
cat = Cat()

animal_sound(dog)  # 输出: Bark
animal_sound(cat)  # 输出: Meow

```
9. 封装
封装是将数据（属性）和与数据操作相关的函数（方法）打包在一起的过程。在 Python 中，使用双下划线 __ 开头的属性或方法会被视为私有。
```python
class Car:
    def __init__(self, brand):
        self.__brand = brand  # 私有属性

    def get_brand(self):
        return self.__brand

car = Car("Tesla")
print(car.get_brand())  # 输出: Tesla
# print(car.__brand)  # 错误，无法直接访问私有属性

```
10. 导入类
1. 导入模块的某个类： from ... import ... 

```python 
from module_name import ClassName
```

2. 导入模块中的多个类：
```python 
from module_name import Class1, Class2, Class3
```
3. 导入模块中的所有类：使用 * 通配符。
```python 
from module_name import *
```
4. 导入模块中的类并重命名： as 关键字来重命名。
```python 
from module_name import ClassName as NewName
```
5. 导入模块并重命名：
```python  
import module_name as new_module_name    
```
6. 使用 import 语句导入模块：它会导入整个模块。   
```python  
import module_name
```
### 2.7 文件和异常
#### 文件操作
1. 打开文件
```python
# 打开一个文件，返回一个文件对象
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

```
2. 读取文件
```python
# 读取文件内容
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

# 逐行读取
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())

```
3. 写入文件
```python
# 写入文件内容
with open('example.txt', 'w') as file:
    file.write('Hello, world!')
```
4. 文件模式
r: 读取模式  
w: 写入模式，如果文件已存在，内容会被清空  
a: 追加模式，如果文件已存在，内容会被添加到文件末尾  
b: 二进制模式，通常用于非文本文件  
+: 更新模式，可以读取和写入文件  
5. path 模块
- 导入path 模块
```python
from pathlib import Path
```
- 创建Path 对象
```python
# 创建一个 Path 对象，可以是一个字符串路径
p = Path('example.txt')

# 或者使用当前目录下的文件
p = Path.cwd() / 'example.txt'
```
- 属性  
name: 路径的文件名   
suffix: 文件名的后缀  
stem: 文件名（不包含后缀）  
-  方法  
exists(): 检查路径是否存在  
is_file(): 检查路径是否是一个文件 
is_dir(): 检查路径是否是一个目录  
glob(): 返回与模式匹配的文件列表  
resolve(): 返回路径的绝对路径  
expanduser(): 扩展用户名占位符（如 ~） 
expandvars(): 扩展环境变量  
- 操作  
absolute(): 返回绝对路径 
relative_to(): 将路径转换为相对于另一个路径的相对路径  
joinpath(): 将多个路径片段合并为一个路径 
parent: 返回路径的父目录 
with_name(): 返回路径的副本，带有指定的文件名  
with_suffix(): 返回路径的副本，带有指定的后缀  
- 示例
```python
# 使用 Path 对象进行文件操作
p = Path('example.txt')

# 检查文件是否存在
if p.exists():
    if p.is_file():
        # 读取文件内容
        content = p.read_text()
        print(content)
    else:
        # 文件不存在或不是文件
        print('Path does not exist or is not a file.')
else:
    # 文件不存在
    print('File does not exist.')

```
#### 异常
1. 异常类型  
IOError：输入/输出错误  
ValueError：值错误  
AttributeError：属性错误  
IndexError：索引错误  
KeyError：键错误  
KeyboardInterrupt：键盘中断  
EOFError：文件结束错误  
ImportError：导入错误   
NameError：未定义名称错误   
SyntaxError：语法错误  
IndentationError：缩进错误  
TypeError：类型错误  
AssertionError：断言错误  
ZeroDivisionError：除零错误
2. 异常处理
```python
try:
    # 可能抛出异常的代码
except Exception as e:
    # 处理异常的代码
finally:
    # 无论是否抛出异常，都会执行的代码

```
3. 异常传递
当一个异常被一个 except 块捕获时，它不会被后续的 except 块捕获。

```python
try:
    # 可能抛出自定义异常的代码
except MyException as e:
    # 处理自定义异常的代码
except Exception as e:
    # 处理其他异常的代码
```

5. assert
断言是另一种检查条件的方法。当条件为 False 时，会抛出 AssertionError
```python
assert condition, message
```
### 2.8 测试
1. 基本测试方法
   - assert 
```python
# assert condition
>>> assert True     # 条件为 true 正常执行
>>> assert False    # 条件为 false 触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
>>> assert 1==1    # 条件为 true 正常执行
>>> assert 1==2    # 条件为 false 触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
 
>>> assert 1==2, '1 不等于 2'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: 1 不等于 2
>>>
```
2. pytest 
   - 测试发现：pytest 能够自动发现测试用例，只需将测试文件放在合适的目录中。
   - 断言：pytest 支持丰富的断言方法，如 assert_equal、assert_true 等
   - 测试标记（Test Markers）：使用 @pytest.mark 装饰器为测试用例添加标记，以便于分类和过滤。
   - 测试参数化（Parameterization）：pytest 支持参数化测试，允许你为测试用例提供多个输入数据。
```python
@pytest.mark.parametrize("a, b, expected", [(1, 2, 3), (3, 4, 7)])
def test_add(a, b, expected):
    assert a + b == expected
```
   -  @pytest.fixture 装饰器
  @pytest.fixture 装饰器用于定义测试中的可重用和可共享的测试数据
**参考：** https://blog.csdn.net/qq_45664055/article/details/131992948
## 3. 第三周python编程练习

### 3.1 SQLArchemy
SQLAlchemy 是一个流行的 Python SQL 工具包和对象关系映射（ORM）框架，它为开发人员提供了一种更为方便的方式来操作数据库。  

**1. 连接方式**  

SQLAlchemy 支持多种数据库连接方式，最常见的是使用数据库的 URI 来连接。URI 格式通常如下：
数据库类型+数据库驱动://用户名:密码@主机名:端口/数据库名    

msql:`mysql+pymysql://username:password@localhost:3306/mydatabase'`

**2. session**   

在 SQLAlchemy 中，`Session` 是一个持久化操作对象的集合，它提供了一个事务性的上下文，用于操作数据库。通过 `Session`，你可以创建、查询、更新和删除数据库中的记录。

要使用 `Session`，首先需要创建一个 `Session` 类的实例。通常情况下，`Session` 是通过配置一个 `sessionmaker` 来创建的，`sessionmaker` 又是通过一个 `Engine` 来创建的。以下是一个简单的例子：

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# 创建数据库连接引擎
engine = create_engine('数据库URI')

# 创建一个Session工厂
Session = sessionmaker(bind=engine)

# 创建Session实例
session = Session() 
```

**3. ORM 数据模型**  

SQLAlchemy ORM 通过 Python 类来表示数据库表，类属性表示表中的列。使用 Column 来定义列，使用 relationship 来定义关系。
Column 参数：
- Integer、String、Float 等：数据类型。
- primary_key：是否为主键。
- unique：是否唯一。
- index：是否建立索引。
- nullable：是否允许为空。
- default：默认值。 
Relation 详解：
relationship 用于定义表之间的关系，它可以用来表示一对多、多对一、一对一和多对多的关系。例如：
```python
 from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

class Parent(Base):
    __tablename__ = 'parents'
    id = Column(Integer, primary_key=True)
    children = relationship("Child", back_populates="parent")

class Child(Base):
    __tablename__ = 'children'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('parents.id'))
    parent = relationship("Parent", back_populates="children")
 ```
 在这个例子中，Parent 类和 Child 类通过 relationship 定义了一对多的关系。Parent 类有一个 children 属性，它关联到 Child 类的多个实例，而 Child 类有一个 parent 属性，它关联到 Parent 类的一个实例。  

**4. 操作数据库方式** 

SQLAlchemy 提供了两种主要的操作数据库的方式：
使用 ORM：通过定义类和对象来操作数据库。  

```python
# 创建新对象
new_user = User(name='new_user')

# 添加到Session
session.add(new_user)

# 提交事务
session.commit()
```
使用 Core：直接使用 SQL 语句来操作数据库。  

```python
# 使用连接执行SQL语句
with engine.connect() as connection:
    result = connection.execute("SELECT * FROM users")
    for row in result:
        print(row)
```

**5. 事务操作**  

SQLAlchemy 中的事务操作是通过 Session 来管理的。当你开始一个事务时，你可以执行多个操作，然后选择提交（commit）或者回滚（rollback）。
```python
# 开始一个事务
session.begin()
try:
    # 执行数据库操作
    user = session.query(User).filter_by(name='user_to_update').first()
    user.name = 'updated_user'
    
    # 提交事务
    session.commit()
except:
    # 如果有异常，回滚事务
    session.rollback()
    raise
```

### 3.2 多线程
https://blog.csdn.net/ifhuke/article/details/128619653
### 3.3 redis
**1. python 连接方式**  

下载 pip install redis
```python
import redis
# 连接到本地 Redis 服务器
r = redis.Redis(host='localhost', port=6379, db=0)
# 如果需要密码认证
# r = redis.Redis(host='localhost', port=6379, db=0, password='your_password')
```
**2. 基础数据操作方式**
```python
import redis
r = redis.Redis(host='localhost', port=6379, db=0)
#-----------字符串 -----------
# 设置键值
r.set('key', 'value')
# 获取键值
value = r.get('key')
# 自增
r.incr('counter')
# ---------------------列表 ---------------------
# 从左侧插入元素
r.lpush('mylist', 'item1')
# 从右侧插入元素
r.rpush('mylist', 'item2')
# 从左侧弹出元素
item = r.lpop('mylist')
# ---------------------集合---------------------
# 添加元素
r.sadd('myset', 'apple')
# 判断元素是否存在
exists = r.sismember('myset', 'apple')
# ---------------------hash---------------------
# 设置哈希表键值对
r.hset('user1', 'name', 'Alice')
r.hset('user1', 'age', 20)
r.hset('user1', 'gender', 'female')
# 获取整个哈希表
hash_table = r.hgetall('user1')
print(hash_table) # 输出 {b'name': b'Alice', b'age': b'20', b'gender': b'female'}
# 获取特定键对应的值
value = r.hget('user1', 'name')
print(value) # 输出 b'Alice'
# 删除哈希表的一个键值对
r.hdel('user1', 'gender')
# 获取所有键名
keys = r.hkeys('user1')
print(keys) # 输出 [b'name', b'age']
# 获取所有键名对应的值
values = r.hvals('user1')
print(values) # 输出 [b'Alice', b'20']
# 批量设置哈希表键值对
r.hmset('user2', {'name': 'Bob', 'age': 25})
# 批量获取哈希表键名对应的值
values = r.hmget('user2', ['name', 'age'])
print(values) # 输出 [b'Bob', b'25']
# ---------------------有序集合---------------------

# 添加有序集合成员和分值
r.zadd('zset1', {'foo': 1.0, 'bar': 2.0, 'baz': 4.0})
# 获取有序集合的成员数
count = r.zcard('zset1')
print(count) # 输出 3
# 获取有序集合指定范围内的成员
members = r.zrange('zset1', 0, -1)
print(members) # 输出 [b'foo', b'bar', b'baz']
# 获取有序集合指定成员的分值
score = r.zscore('zset1', 'bar')
print(score) # 输出 2.0
# 获取有序集合指定范围内成员的数量
count = r.zcount('zset1', 1.5, 3.5)
print(count) # 输出 1
# 删除有序集合中一个成员
r.zrem('zset1', 'bar')
# 获取有序集合中指定范围内的成员和分值
with_scores = r.zrangebyscore('zset1', 0, 5, withscores=True)
print(with_scores) # 输出 [(b'foo', 1.0), (b'baz', 4.0)]
```

**3. 事务和管道**  

**管道：**  

在Redis中，管道（pipeline）是指可以将多个Redis命令依次发送给Redis，让Redis 一次性执行这些命令并返回结果的机制。使用管道可以大大减少客户端与Redis的网络通信次数，提高Redis的处理效率，是优化Redis性能的重要手段之一。
在redis-py库中，可以使用pipeline()方法创建一个管道对象，并对该对象连续调用多个 Redis 命令并提交到 Redis 进行执行。提交执行后，每个命令都会获取到这些命令的执行结果，并按照请求的顺序返回给客户端。
- **特点：**
1.可以一次性发送多条命令并在执行完后一次性将结果返回
2.pipeline通过减少客户端与Redis的通信次数来实现降低往返延时时间
- **实现原理：**
(1) 管道pipeline实现的原理是队列，队列是先进先出，这样就保证数据的顺序性
(2) Client可以将三个命令放到一个tcp报文一起发送
(3)Server则可以将三条命令的处理结果放到一个tcp报文返回
- **基本使用**
1.使用 pipeline() 方法创建一个新的 Pipeline 对象，并向该管道对象连续调用了三个不同的 SET 命令，分别设置了三个不同的键名和对应的键值
2.通过 execute() 方法提交管道内所有的命令。Redis 服务器一次性执行管道内所有的命令，并将结果返回给客户端
3.最后输出Redis 管道执行的结果到控制台，其中包含了每个 SET 命令的执行结果
```python
trans = r.pipeline(transaction=True)
# 开启事务
trans.multi()
# 向两个键名分别设置不同的值
trans.set('foo', 'hello')
trans.set('bar', 'world')
# 在 Redis 事务中执行以上命令，并获取执行结果
result = trans.execute()
# 输出 Redis 事务执行结果
print(result)
```
**事务**  

事务 Redis 通过 MULTI 和 EXEC 来实现事务，MULTI 开启一个事务，EXEC 提交多个命令到 Redis 执行，可以保证单位时间内只有当前请求在访问 Redis 服务器，其他读写操作会等待这个事务结束后才能进行，从而保证了数据一致性。
- **基本使用**
1.创建一个 redis.StrictRedis 实例，并且设置 transaction 参数为 True，表示开启 Redis 事务
2.使用 pipeline() 方法创建一个新的 Pipeline 对象，并将其 transaction 参数设置为 True，表示这个 Pipeline 是用于 Redis 事务的
3.调用 multi() 方法开启Redis 事务，之后向两个不同的键名 foo 和 bar 分别设置了不同的字符串值
4.最后通过 execute() 方法提交事务，Redis 将一次性执行整个事务并返回每个命令的执行结果
```python
# 使用 Redis 事务
trans = r.pipeline(transaction=True)
# 开启事务
trans.multi()
# 向两个键名分别设置不同的值
trans.set('foo', 'hello')
trans.set('bar', 'world')
# 在 Redis 事务中执行以上命令，并获取执行结果
result = trans.execute()
# 输出 Redis 事务执行结果
print(result)
```
 **区别**  
 
在Redis中，事务（transaction）和管道（pipeline）都是用于批量执行命令的方式，但二者有本质上的不同：

1.调用方式不同

使用事务时，需要先通过MULTI命令将客户端设置为事务模式，然后按照一定的顺序添加执行的多个命令，最后通过EXEC命令将操作提交到服务器执行。

使用管道时，则是对同一个连接对象上连续调用多个Redis命令并且在最后统一执行这些命令。

2.发送机制不同

Redis事务的逻辑单元可以确保所有被包含的命令“原子性”地执行，即要么全部执行成功完成，要么全部回滚；而Redis>运用管道的方法仅仅是优化传输，将多个命令打包发送到Redis服务节点，并在结果关闭时进行收集处理，以达到多个请求一次通信的目的。

3.回滚能力不同
Redis事务提交的过程中如果某个命令执行失败了，后面的命令则都不会再执行，已经执行过的命令不会回滚。当然在EXEC之前可以通过DISCARD命令清空已经放入到事务队列里面的命令；而管道机制暂时没有回滚的能力。

## 4. 第四周 自动驾驶数据加工与清洗
### 4.1 下载数据
使用request.get(url) 进行下载，url 位于network 里
### 4.2 数据清洗-存储
#### 4.2.1. 数据清洗
   - 数据结构
```
   single-vehicle-side                     # 车端数据集（DAIR-V2X-V）
    ├── image					        # 图像
        ├── {id}.jpg
    ├── velodyne                        # 点云
        ├── {id}.pcd                    
    ├── calib                           # 标定参数
        ├── camera_intrinsic            # 相机参数
            ├── {id}.json
                ├── "cam_D"
                ├── "cam_K"
        ├── lidar_to_camera             # LiDAR坐标系到相机坐标系变换参数
            ├── {id}.json
                ├── "rotation"
                ├── "translation"
    ├── label							# 标注文件
        ├── camera                      # 标注文件（以图像时间戳为基准，3D标注贴合图像中的障碍物）
            ├── {id}.json
                ├── "type"
                ├── "occluded_state"
                ├── "truncated_state"
                ├── "alpha"
                ├── "2d_box"
                    ├── "xmin"
                    ├── "ymin"
                    ├── "xmax"
                    ├── "ymax"
                ├── "3d_dimensions":
                    ├── "h" 
                    ├── "w"
                    ├── "l" 
                ├── "3d_location":
                    ├── "x"
                    ├── "y"
                    ├── "z"
                ├── "rotation"
        ├── lidar                       # 标注文件（以点云时间戳为基准，3D标注贴合点云中的障碍物）
            ├── {id}.json
                ├── # 同上
    ├── data_info.json                  # 数据索引
```

#### 4.2.2. 数据存储
##### 4.2.2.1 **数据类型**
**(1) datetime 与 timestamp**
**DATETIME**
1. 存储格式：DATETIME 以 'YYYY-MM-DD HH:MM:SS' 的格式存储日期和时间，其中 YYYY 表示四位年份，MM 表示月份，DD 表示日期，HH 表示小时，MM 表示分钟，SS 表示秒。   
2. 存储范围：DATETIME 可以存储从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59' 的时间。     
3. 存储空间：DATETIME 占用8字节的存储空间。   
4. 时区无关：DATETIME 不包含时区信息，它存储的是一个固定的日期和时间值。              
5. 默认值：DATETIME 可以设置默认值，例如 DEFAULT CURRENT_TIMESTAMP 表示插入记录时如果没有指定时间，则使用当前时间。   
     
**TIMESTAMP**

1. 存储格式：TIMESTAMP 也以 'YYYY-MM-DD HH:MM:SS' 的格式存储日期和时间，与 DATETIME 相同。  
2. 存储范围：TIMESTAMP 可以存储从 '1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC 的时间。   
3. 存储空间：TIMESTAMP 占用4字节的存储空间，因此它比 DATETIME 更节省空间。      
4. 时区相关：TIMESTAMP 存储的是自 '1970-01-01 00:00:01' UTC 以来的秒数，它在内部以UTC时间存储，但在显示时会根据当前会话的时区设置进行转换。       
5. 自动更新：TIMESTAMP 可以设置为在记录更新时自动更新为当前时间，例如 ON UPDATE CURRENT_TIMESTAMP  
      
**时间戳的精度**
秒级时间戳：通常为10位数字，表示自1970年1月1日以来的秒数。
毫秒级时间戳：通常为13位数字，表示自1970年1月1日以来的毫秒数（千分之一秒）。
微秒级时间戳：通常为16位数字，表示自1970年1月1日以来的微秒数（百万分之一秒）。  

注：**数据中的时间戳是16位数字，微秒级别，但是考虑到自动驾驶数据的重点不在于微秒级别的时间，因此将时间精度调整为秒级，使用Datetime 类型进行存储，若要调整到微妙级别，修改方式为datetime(6)** 

**(2) 数据精度**
```
"type": "Car",
"occluded_state": 0,
"truncated_state": 0,
"alpha": 0.3092128173071816,
"2d_box": {
    "xmin": 0,
    "ymin": 527.938232,
    "xmax": 69.723068,
    "ymax": 637.4556269999999
},
"3d_dimensions": {
    "h": 2.036748,
    "w": 2.073565,
    "l": 4.252306
},
"3d_location": {
    "x": 32.84116,
    "y": 9.75075,
    "z": -1.040589
},
"rotation": -1.578873
"camera_intrinsic_cam_D":[ -0.382041,0.335649,0.000523,0.000634,0.0],
"camera_intrinsic_cam_D":[3996.487567,0.0,955.58618,0.0,3963.430994,527.646219,0.0, 0.0,1.0]
"lidar_to_camera_rotation": [[ 0.006283,-0.999979,-0.001899],[    -0.005334, 0.001865, -0.999984],[ 0.999966,0.006293,-0.005322]],
"lidar_to_camera_translation": [[ -0.298036],[-0.666812],[ -0.516927]]
```
以上是数据中涉及数据精度的部分，其中考量后，2d_box、3d_dimensions、3d_location、cam_D、cam_K、lidar_to_camera_rotation、lidar_to_camera_translation 均采用json 格式存储，而json 采用文本格式存储，因此不会产生精度损失问题。
需要考虑的是alpha 和 rotation ,经过查询，alpha 最大为1位整数，18位小数，使用float会损失精度，因此采用decimal 格式存储，预留一位，最终采用**decimal(21,19)**的格式存储；
而rotation 最大为1位整数，10位小数，使用float会损失精度，因此采用decimal 格式存储，预留一位，最终采用**decimal(13,11)**的格式存储；

**(3) JSON 格式**

MySQL 5.7及更高版本中可用，它提供了一系列的函数来处理JSON数据。 
1. JSON数据类型可以存储以下类型的值：
- 对象（字典）：键值对的集合，键必须是字符串。
- 数组：值的有序集合，可以包含不同类型的值。
- 字符串、数字、布尔值或null。
1. 常用查询函数：
   
| 函数 | 用途|
|----|----|
|JSON_EXTRACT(json_doc, path)|从JSON文档中提取数据。|
|JSON_ARRAY(val1, val2, ...)|创建一个JSON数组。|
|JSON_OBJECT(key1, val1, key2, val2, ...)|创建一个JSON对象。|
|JSON_SET(json_doc, path, val[, path, val]...)|设置JSON文档中的值。|
|JSON_REPLACE(json_doc, path, val[, path, val]...)|替换JSON文档中的值。|
|JSON_REMOVE(json_doc, path[, path]...)|从JSON文档中移除数据|

3. 注意事项
JSON数据在存储时会被自动校验，确保其格式正确。  
JSON列不支持索引，但可以通过创建虚拟列并对其进行索引来优化查询。 
在处理大量数据时，直接在JSON列上进行查询可能会比较慢  

4. 和 varchar、text 、longtext的比较 
- 数据存储量 
  
VARCHAR：可变长度的字符串类型，可以存储最多65535个字符。
TEXT：不可变长度的字符串类型，可以存储最多65535个字符。
LONGTEXT：不可变长度的字符串类型，可以存储最多4294967295个字符。
JSON：可以存储大于等于4GB的JSON文档。
-  性能
VARCHAR：由于是可变长度的字符串类型，当存储的数据量较大时，会占用更多的存储空间，导致查询效率变慢。
TEXT：使用行级锁，支持并发读写，在存储大量文本时，性能较好。
LONGTEXT：与TEXT类似，但可以存储更大的文本数据，适用于存储较长的文本、HTML或XML文档等。
JSON：由于是BLOB类型的数据，因此只能进行简单的查询操作，如果需要进行复杂的查询，建议将JSON数据解析出来后再存储到其他字段中。
5. 注
（1）该数据中2b_box 、3d_dimensions 、rotation 、translation 、cam_D、cam_K 等数据均是以整体的方式呈现，且查询时通常需要的是整体，而不是其中的某一项，因此最终选用json 格式存储。  
（2）若对数据的需求是json 中的某一项经常被用到，则赢将json 转换成varchar 以提高查询效率。

 ##### 4.2.2.2 **单表存储 or 多表关联**
**（1）单表存储**
即将所有的信息整理在一张表上，优点在于简单直接，所有数据都在一个表中，便于查询全部数据。但是表结构变得更加复杂，不便于更新。
数据字段如下：

| 字段名 | 字段名 | 字段名 | 字段名 |
| --- | --- | --- | --- |
| image_id | image_path | image_timestamp | pointcloud_path |
| point_cloud_stamp | calib_lidar_to_camera_path | label_camera_std_path | label_lidar_std_path |
| label_camera_type | label_camera_occluded_state | label_camera_truncated_state | label_camera_alpha |
| label_camera_2d_box | label_camera_3d_dimensions | label_camera_3d_location | label_camera_rotation |
| label_lidar_type | label_lidar_occluded_state | label_lidar_truncated_state | label_lidar_alpha |
| label_lidar_2d_box | label_lidar_3d_dimensions | label_lidar_3d_location | label_lidar_rotation |
| camera_intrinsic_cam_D | camera_intrinsic_cam_K | lidar_to_camera_rotation | lidar_to_camera_translation |
| velodyne_size | 

（**2） 多表关联**
即根据数据的逻辑关系分为不同的表，每个表专注于存储一类相关的信息，并通过外键与主键建立联系。
此数据可以分的表为：

|表名|
|:--:|
|图像信息表 Images|
|相机校准信息表 CameraCalibrations|
|激光雷达到相机的校准信息表 LidarToCameraCalibrations|
|相机标签信息表 CameraLabels|
|激光雷达标签信息表 LidarLabels|

**优点** 减少了数据冗余，每个表只存储相关信息；更新单个字段时效率更高，因为只更新相关表。
**缺点** 查询时可能需要多表连接，增加了查询的复杂性；维护多个表可能比维护单个表更复杂。
**（3）混合模式**
分析表结构，发现字段间的冗余主要在于以相机为基准的标注文件和以雷达为基准的标注文件。二者标签信息完全相同，若是单表则会多出一倍字段，若是将此标签信息从主表中抽离出来，则主要加一个label_type 字段即可区分两种文件。
而其他的字段信息各不相同，可以放在主表上，方便查询。
   
**注：因为数据中没有缺失值，且数据主要用于查询，更新频率不高，因此选择更为简便的单表模式。**  

 ##### 4.2.2.3 **session 与 线程安全**  

session不是线程安全的，并且我们一般session对象都是全局的，那么在多线程情况下，当多个线程共享一个session时，数据处理就会发生错误。
为了保证线程安全，需使用scoped_session方法:
**（1）内部原理**
session对象包含了三个重要的部分：```标识映射（Identity Map）```、```对象的状态 / 状态跟踪```、```事务``` 

**标识映射**：标识映射是与ORM关联的集合，通过标识映射保证了数据库操作的准确性。
具体的实现原理是：维护一个Python字典（IdentityMap），关联这个Session对象到数据库ID的映射，当应用程序想要获取一个session对象时，若该对象不存在，标识映射会加载该对象并缓存，若该对象已存在，则直接获取。这样的好处是：已经被请求过的session对象缓存下来，不需要连接加载多次，造成额外的开销；
避免了数据不一致

**状态跟踪**：一个Session对象从创建到销毁，依次经历四种状态，分别是：
① Transient：刚new出来的对象，还不在会话中，也没有保存到数据库。
② Pending：transient的对象调用add后，就会变成pending状态，这时会加入sqlalchemy的监管范围，数据并未更新到数据库。
 ③ Persistent：该状态表明数据库里已经记录了该对象，在两种情况下对象处于该状态：一是通过flush()方法刷新pending对象，二是从数据库query()得到对象。
④ Detached：在会话中的事务提交之后，所有的对象都将是Detached状态。     

Session对象采用了**弱引用机制**，所谓弱引用，就是说，在保存了对象的引用的情况下，对象仍然可能被垃圾回收器回收。在某一时刻通过引用访问对象时，对象可能存在也可能不存在，如果对象不存在，就重新从数据库中加载对象。而如果不希望对象被回收，只需要另外保存一个对象的强引用即可 。
session对象包括三个属性：new：刚加入会话的对象、dirty：刚被修改的对象、deleted：在会话中被删除的对象

-  session 连接关闭
```python
@contextmanager
def session_scope():
    """提供一个事务的会话范围。"""
    session = Session()
    try:
        yield session
        session.commit()
    except Exception as e:
        print(e)
        session.rollback()  # 发生异常时回滚
        raise
    finally:
        session.close()  # 确保最后关闭 session
with session_scope() as session:
    '''
    '''
# with 块结束时，session_scope() 会自动提交事务或回滚，并关闭 session
```

### 4.3 数据应用
#### 4.3.1 FastAPI
1. 基础内容
(1)环境准备
```shell
pip install fastapi uvicorn
# 安装 fastapi 和 ASGI 服务
```
(2)基础使用
```python
from fastapi import FastAPI  

app = FastAPI()  
​
@app.get('/')  
def root():  
    return {'message': 'Hello World'} 
``` 
(3)启动两种方式
```shell
uvicorn main:app --reload
```
```python
if __name__ == '__main__':
    #注意，run的第一个参数 必须是文件名:应用程序名
    uvicorn.run("query:app", port=8000,  reload=True)
```
main:文件main.py（python模块）
app：在模块中app=FastAPI()行中创建的对象
--reload：代码更改后自动重启服务（上线时该参数值不能为true，降低性能
(4)API 交互式文档
http://127.0.0.1:8000/docs
2. 路径
路径主要包括一下三个部分，路径、操作和函数
路径：URL 的一部分，通常表示 API 的一个特定段或资源。
操作：一个 HTTP 方法。例如：GET, POST, PUT, DELETE, 等。
函数：当请求特定路径和操作时，FastAPI 将执行的 Python 函数。  
(1)装饰器
@app.get()  
@app.post()  
@app.put()  
@app.patch()  
@app.delete()   
@app.options() 
@app.head()      
@app.trace()   
(2)解释参数
- tags 展示在每个接口上面的信息  
- summary 接口描述的总结信息
- describe: 接口信息的详细描述
- response_description：响应描述
- deprecated：接口是否废弃，默认是False
(3)请求
- 路径参数：这些参数是 URL 路径的一部分。在路由装饰器中用花括号 {} 指定，在函数参数中使用类型注解来定义。
```python
@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}
```
- 查询参数：这些参数是可选的，通常用于过滤、排序或分页。可以使用**Query**或直接在函数参数中定义默认值。
可以使用 Query 的 min_length、max_length、regex 等参数进行数据验证。
```python
@app.get("/items/")
async def read_items(q: str = Query(None)):
    if q:
        return {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    return {"items": [{"item_id": "Baz"}]}
```
- 请求体：对于 POST、PUT、DELETE 等方法，请求体通常包含要创建、更新或删除的数据。可以使用 **Pydantic** 模型来定义请求体
```python
class Item(BaseModel):
    name: str
    price: float

@app.post("/items/")
async def create_item(item: Item):
    return item
```
- 表单数据：对于表单数据的提交，可以使用 **Form** 来定义表单字段。
```python
@app.post("/login/")
async def login(username: str = Form(...), password: str = Form(...)):
    return {"username": username}
```
- 文件上传：FastAPI 支持文件上传，可以使用 **File 和 UploadFile **来定义文件字段
```python
@app.post("/upload/")
async def upload_file(file: UploadFile = File(...)):
    return {"filename": file.filename}
```
#### 4.3.2 Pydantic 模型
Pydantic 是一个 Python 库，用于数据解析和验证。它主要基于 Python 类型提示来实现数据的校验和设定限制条件。在 Pydantic 中，BaseModel 是一个核心基类，用于创建数据模型。  
主要作用如下几点:
**(1)数据验证（Validation）:**
BaseModel 类提供了自动数据验证的功能。当你创建一个基于 BaseModel 的子类并且为其字段添加类型注解（type annotations），Pydantic 会在实例化对象时自动校验给定的数据是否符合预期类型和约束。
**(2)数据转换（Conversion）:**
Pydantic 会尝试将输入数据转换成声明的数据类型。例如，如果一个字段被声明为 int 类型，但输入数据是一个数字字符串，如 “123”，Pydantic 会尝试转换这个字符串为整型 123。
**(3)模型实例化:**
BaseModel 中提供的构造器可以让你轻松地实例化模型，并为其填充数据。在实例化过程中，数据会自动经过验证和转换。
**(4)错误处理:**
如果数据不符合预期，Pydantic 会抛出描述性的错误（通常是 ValidationError 异常），告诉你哪些数据是无效的以及具体原因。
**(5)字段别名:**
BaseModel 允许你为模型的字段设定别名，这样在解析外部数据如 JSON 时，如果其字段名称与你的模型字段不一致，依然可以正确匹配和解析。
(6)JSON序列化与反序列化:
BaseModel 提供了 .json() 和 .parse_raw() 两个方法用于模型对象的 JSON 序列化（将 Python 对象转换为 JSON 字符串）和反序列化（将 JSON 字符串或二进制数据解析成 Python 对象）。

**Field 函数**用于提供更多的配置和校验选项给 BaseModel 的字段。通过使用 Field，你可以为模型的字段**指定默认值**、**验证规则**、**字段描述**、**别名**等。  

可以使用**validator** 进行自定义校验，比如：
 @validator('email')
```python
from pydantic import BaseModel, Field, ValidationError, validator

class User(BaseModel):
    # 使用 Field 指定默认值、别名和校验规则
    full_name: str = Field(default='John Doe', alias='name')
    age: int = Field(..., ge=0, le=120)  # `...` 表示该字段是必需的
    email: str = Field(default='', alias='email_address')

    # 自定义校验器
    @validator('email')
    def email_must_contain_at(cls, v):
        if '@' not in v:
            raise ValueError('Email must contain @')
        return v

    # 使用 Field 的 description 属性为字段添加描述
    class Config:
        fields = {
            'full_name': {'description': 'The full name of the user'},
            'age': {'description': 'The age of the user'},
            'email': {'description': 'The email address of the user'}
        }
```

#### 4.3.3 响应模型
- 直接通过return 返回数据
- 自定义响应模型 shiyong pydantic
```python
class Item(BaseModel):
    name: str
    price: float

@app.post("/items/", response_model=Item)
async def create_item(item: Item):
    return item
```
- 自定义响应状态码
```python
@app.post("/items/", status_code=201)
async def create_item(item: Item):
    return item
```
- 重定向
```python
from fastapi.responses import RedirectResponse

@app.get("/items/")
async def read_items():
    return RedirectResponse(url="/new_items/")
```
#### 4.3.3 静态资源下载
1. 使用fileResponse
创建一个路径操作来返回特定的静态文件，使用response,例如：
```python
@app.get("/static/image/{image_name}.jpg")
async def static_file(image_name: str):
    image_path = '/home/sss/data_cleaning/single-vehicle-side-example/image/' + image_name +'.jpg'
    if not os.path.exists(image_path):
       raise HTTPException(status_code=404, detail="Image not found")
    response = FileResponse(image_path, media_type="image/jpeg")
    response.headers["Content-Disposition"] = "attachment; image_name=" + image_name
    return response
```
2. 使用steamingResponse 返回大文件
```python
@app.get("/download/video")
async def download_video():
    file_path = "static/video.mp4"
    def file_stream():
        with open(file_path, "rb") as f:
            yield from f
    return StreamingResponse(file_stream(), media_type="video/mp4")
```
