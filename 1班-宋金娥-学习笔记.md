
- [学习记录](#学习记录)
  - [1. 第一周通用技能学习](#1-第一周通用技能学习)
    - [1.1 git](#11-git)
    - [1.2 linux/ shell](#12-linux-shell)
      - [目录相关](#目录相关)
      - [磁盘管理](#磁盘管理)
      - [进程管理](#进程管理)
      - [shell 文件](#shell-文件)
    - [1.3 docker](#13-docker)
    - [1.4 mysql](#14-mysql)
    - [1.5 redis](#15-redis)
  - [2. Python 编程练习](#2-python-编程练习)
    - [2.1 列表（List）](#21-列表list)
    - [2.2 条件语句](#22-条件语句)
    - [2.3 字典](#23-字典)
    - [2.4 用户输入和while 循环](#24-用户输入和while-循环)
    - [2.5 函数](#25-函数)
    - [2.6 类](#26-类)
    - [2.7 文件和异常](#27-文件和异常)
      - [文件操作](#文件操作)
      - [异常](#异常)
    - [2.8 测试](#28-测试)
  - [3. 第三周python编程练习](#3-第三周python编程练习)
    - [3.1 SQLArchemy](#31-sqlarchemy)
    - [3.2 多线程](#32-多线程)
    - [3.3 redis](#33-redis)

# 学习记录
## 1. 第一周通用技能学习
### 1.1 git
![image](https://github.com/sje123456/2024_training/assets/71172395/794ff901-a44b-4c55-bd25-a31718fe8b5d)
| 作用 | 命令 | 备注 |
| ---- | ---- | ---- |
| 添加文件到暂存区 | git add | |
| 查看仓库当前的状态，显示有变更的文件 | git status | |
| 比较文件的不同，即暂存区和工作区的差异 | git diff | |
| 提交暂存区到本地仓库 | git commit | |
| 回退版本 | git reset | |
| 将文件从暂存区和工作区中删除 | git rm | |
| 移动或重命名工作区文件 | git mv ||
| 恢复或撤销文件的更改 | git restore | Git 2.23 版本引入 |
| 查看分支 | git branch| |
| 创建分支 |git branch (branchname)| | 
| 切换分支 |git checkout (branchname)| |
| 更清晰地切换分支 | git switch | Git 2.23 版本引入 | |
| 创建分支并切换 |  git checkout **-b** (branchname)| |
| 删除分支 | git branch -d (branchname) | |
| 分支合并 | git merge (branchname) | 将branchname 分支合并到当前分支；合并冲突需要手动修改|



### 1.2 linux/ shell
#### 目录相关
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `ls` | 列出目录及文件名 | `-l`: 长格式列表，显示文件的详细属性信息<br>`-a`: 列出所有文件，包括以`.`开头的隐藏文件<br>`-h`: 以人类可读的格式显示文件大小，如KB、MB | `ls -l`<br>`ls -a`<br>`ls -lh` |
| `cd` | 切换目录 | `-`: 返回到上一个目录<br>`~`: 切换到当前用户的主目录 | `cd -`<br>`cd ~` |
| `pwd` | 显示目前的目录 | `-P`: 显示实际路径，即物理路径<br>`-L`: 显示逻辑路径，即链接路径 | `pwd`<br>`pwd -P`<br>`pwd -L` |
| `mkdir` | 创建一个新的目录 | `-p`: 创建多级目录，若上级目录不存在则一并创建<br>`-m`: 设置新创建目录的权限 | `mkdir -p dir1/dir2`<br>`mkdir -m 755 new_directory` |
| `rmdir` | 删除一个空的目录 | (无) | `rmdir directory_name` |
| `cp` | 复制文件或目录 | `-r`: 递归复制目录及其子目录<br>`-p`: 保持源文件的属性，如权限和时间戳<br>`-v`: 显示复制的详细过程 | `cp -r dir1 dir2`<br>`cp -p file1 file2`<br>`cp -v file1 dir1` |
| `rm` | 删除文件或目录 | `-r`: 递归删除目录及其内容<br>`-f`: 强制删除，不提示确认<br>`-i`: 交互式删除，删除前提示确认 | `rm -r dir1`<br>`rm -f file1`<br>`rm -i file1` |
| `mv` | 移动文件与目录，或修改文件与目录的名称 | `-i`: 交互式操作，如果目标已存在则提示确认<br>`-n`: 不覆盖已存在的目标文件<br>`-v`: 显示移动或重命名过程的详细信息 | `mv -i file1 file2`<br>`mv -n file1 dir1`<br>`mv -v file1 dir1/file2` |
#### 磁盘管理
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `df` | 显示磁盘空间使用情况 | `-h`: 以人类可读的格式显示磁盘空间（如GB、MB）<br>`-T`: 显示文件系统的类型 | `df -h`<br>`df -T` |
| `du` | 显示目录或文件的磁盘使用情况 | `-h`: 以人类可读的格式显示大小<br>`-s`: 只显示总计的大小，不显示每个子目录的大小 | `du -h`<br>`du -sh /path/to/directory` |
| `fdisk` | 磁盘分区表管理 | `-l`: 列出所有磁盘的分区表信息 | `fdisk -l`<br>`fdisk /dev/sdb` 需要sudo|
| `mkfs` | 创建文件系统 | `-t`: 指定文件系统的类型（如ext4, xfs） | `mkfs -t ext4 /dev/sdb1` |
| `mount` | 挂载文件系统 | `-t`: 指定文件系统的类型<br>`-o`: 指定挂载选项 | `mount -t ext4 /dev/sdb1 /mount/point` |
| `umount` | 卸载挂载的文件系统 | 无 | `umount /mount/point` |
| `lsblk` | 列出所有可用磁盘及其分区 | `-f`: 显示文件系统类型 | `lsblk`<br>`lsblk -f` |
| `parted` | 磁盘分区和分区大小调整 | 无 | `parted /dev/sdb` |
| `pvcreate` | 创建物理卷（LVM） | 无 | `pvcreate /dev/sdb1` |
| `vgcreate` | 创建卷组（LVM） | 无 | `vgcreate my_volume_group /dev/sdb1` |
| `lvcreate` | 创建逻辑卷（LVM） | `-L`: 指定逻辑卷的大小<br>`-n`: 指定逻辑卷的名称 | `lvcreate -L 10G -n my_logical_volume my_volume_group` |
#### 进程管理
| 命令 | 功能描述 | 常用参数及解释 | 使用示例 |
|------|-----------|----------------|----------|
| `ps` | 显示当前进程的快照 | `-ef`: 显示所有进程，包括命令行参数<br>`-aux`: 显示所有进程，包括用户和CPU、内存使用情况 | `ps -ef`<br>`ps -aux` |
| `top` | 显示系统运行的进程 | `-u`: 显示指定用户的进程<br>`-p`: 显示指定PID的进程 | `top`<br>`top -u username`<br>`top -p PID` <br>默认按照CPU 使用率降序排列<br>按E 切换内存排序，<br> M 切换内存使用率排序 |
| `htop` | 一个更高级的进程查看器 | (通常不需要参数) | `htop` |
| `pgrep` | 搜索进程并列出匹配到的进程ID | `-u`: 列出指定用户的进程ID<br>`-l`: 显示进程名称 | `pgrep process_name`<br>`pgrep -u username`<br>`pgrep -l process_name` |
| `kill` | 发送信号到指定进程 | `-9`: 发送SIGKILL信号，强制结束进程 | `kill PID`<br>`kill -9 PID` |
| `pkill` | 根据名称杀死进程 | `-f`: 根据完整命令行杀死进程 | `pkill process_name`<br>`pkill -f process_name` |
| `renice` | 改变运行进程的优先级 | `new_niceness`: 新的优先级值 | `renice new_niceness PID` |
| `nohup` | 运行一个命令，忽略挂起信号 | `command`: 要运行的命令 | `nohup command &` |
| `nice` | 以指定的优先级运行命令 | `niceness`: 优先级值<br>`command`: 要运行的命令 | `nice -n niceness command` |  

**备注: 分析磁盘IO 还可用iotop <br>
        perf是Linux性能分析工具，可用pref命令分析CPU性能问题，可以识别哪些进程、函数或线程正在使用CPU资源**
#### shell 文件
```bash
##!/bin/bash
## 这是脚本的第一行，称为释伴（shebang），告诉系统应该使用哪个解释器来执行这个脚本。

## 定义变量
USERNAME="user"
PASSWORD="password123"

## 打印输出
echo "Hello, World!"

## 使用变量
echo "Username: $USERNAME"

## 条件判断
if [ "$USERNAME" == "admin" ]; then
    echo "Welcome, admin!"
elif [ "$USERNAME" == "user" ]; then
    echo "Welcome, user!"
else
    echo "Unknown user"
fi

## 循环
for i in {1..5}; do
    echo "Loop number: $i"
done

## 函数定义
function greet() {
    echo "Hello, $1!"
}

## 调用函数
greet "Alice"

## 接收命令行参数
echo "First command line argument: $1"

## 输出重定向
echo "This is an error message" >&2

## 执行命令并检查退出状态
ls -l /etc/passwd
if [ $? -eq 0 ]; then
    echo "Command succeeded"
else
    echo "Command failed"
fi

## 读取用户输入
read -p "Enter your name: " NAME
echo "Hello, $NAME!"

## 使用case语句
case "$USERNAME" in
    "admin")
        echo "You are an admin."
        ;;
    "user")
        echo "You are a regular user."
        ;;
    *)
        echo "Unknown user."
        ;;
esac

## 脚本结束
exit 0
```
- 特殊参数说明：
  
| 参数 | 说明 |
|------|------|
| `$##` | 传递到脚本的参数个数 |
| `$*` | 以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1$2 … $n"的形式输出所有参数。 |
| `$$` | 脚本运行的当前进程ID号 |
| `$!` | 后台运行的最后一个进程的ID号 |
| `$@` | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| `$-` | 显示Shell使用的当前选项，与`set`命令功能相同。 |
| `$?` | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。用于检查是否有误。 |
### 1.3 docker
docker 及 docker compose 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/91743bce-9f36-4a94-93c8-02385c7d1674)
![image](https://github.com/sje123456/2024_training/assets/71172395/dfc210b7-7fbe-4d2e-92a1-9f18dbe3aa3b)
![image](https://github.com/sje123456/2024_training/assets/71172395/348d621b-916d-4b9f-8043-fe33e24cf54a)

docker-compose  是用来定义和运行多容器docker 应用程序的工具，能够在docker节点上，以单引擎模式进行多容器应用的部署和管理。
compose 使用yaml 文件来定义多容器之间的关系（配置应用程序所需的所有服务），然后通过docker-compose up 命令执行一个yaml 文件，就可以从yml 文件配置中创阿金并启动所有服务，把完整的应用跑起来。
本质上。compose 把yaml 文件解析成docker 命令的参数，然后调用相应的docker命令行接口，基于docker API 完成应用的部署，从而将应用以容器化的方式管理起来。

| 命令 | 功能描述 | 使用示例 |
|------|-----------|----------|
| `docker-compose up` | 启动或重启服务 | `docker-compose up` |
| `docker-compose down` | 停止所有服务并移除容器、网络和数据卷 | `docker-compose down` |
| `docker-compose stop` | 停止所有服务 | `docker-compose stop` |
| `docker-compose start` | 启动所有服务 | `docker-compose start` |
| `docker-compose restart` | 重启所有服务 | `docker-compose restart` |
| `docker-compose ps` | 列出服务及其状态 | `docker-compose ps` |
| `docker-compose logs` | 查看服务的日志输出 | `docker-compose logs service_name` |
| `docker-compose exec` | 在服务容器中执行命令 | `docker-compose exec service_name command` |
| `docker-compose scale` | 更改服务容器的数量 | `docker-compose scale service_name=2` |
| `docker-compose kill` | 停止服务容器 | `docker-compose kill service_name` |
| `docker-compose pull` | 拉取服务依赖的镜像 | `docker-compose pull service_name` |
| `docker-compose build` | 构建或重新构建服务镜像 | `docker-compose build service_name` |
| `docker-compose config` | 验证Compose文件中的配置 | `docker-compose config` |
| `docker-compose create` | 创建服务容器但不启动 | `docker-compose create service_name` |
| `docker-compose run` | 一次性运行服务 | `docker-compose run service_name command` |

### 1.4 mysql
mysql 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/465ec0c3-f51f-40d6-a55b-22f039d781a1)
修改权限

![image](https://github.com/sje123456/2024_training/assets/71172395/6cd8acb4-31d0-4065-af79-9049ff956348)

创建库表、增删改查示例

![image](https://github.com/sje123456/2024_training/assets/71172395/c1436be0-fd8e-450a-a759-19dc05d845f8)
### 1.5 redis
redis 启动成功

![image](https://github.com/sje123456/2024_training/assets/71172395/d136d677-2322-49a6-ad4f-ec05667ff756)

增删改查示例

![image](https://github.com/sje123456/2024_training/assets/71172395/a9bf0577-5d45-44be-a2f2-0a6bcb2ec860)

 
## 2. Python 编程练习
### 2.1 列表（List）

 基本特性

1. **定义**  
   列表是由逗号分隔的元素组成的，元素之间可以包含空格。

   示例：`my_list = [1, 2, 3, 4, 5]`

2. **索引和切片**

   列表中的每个元素都有一个索引，从0开始。

   使用索引来访问或修改列表中的元素。

   示例：`my_list[0]` 访问第一个元素，`my_list[2:4]` 获取第三个和第四个元素。

3. **添加元素**

   使用 `append()` 方法在列表末尾添加一个元素。

   使用 `insert()` 方法在指定索引处添加一个元素。


4. **删除元素**

   使用 `pop()` 方法删除指定索引处的元素。

   使用 `remove()` 方法删除指定元素。


5. **修改元素**

   直接通过索引来修改元素值。


6. **遍历列表**

   使用 `for` 循环来遍历列表中的每个元素。

7. **列表推导式**

   列表推导式是一种创建列表的快捷方式。
   示例：`squares = [x**2 for x in range(5)]`

8. **列表方法**

   - `len()`：获取列表的长度。
   - `reverse()`：反转列表元素的排列顺序。
   - `sort()`：对列表进行排序。
   - `sorted()`：返回一个新的排序列表，不修改原列表。
   - `index()`：返回列表中指定元素的索引。
   - `count()`：返回列表中指定元素的次数。

9. **列表的嵌套**

   列表可以包含其他列表，形成列表的嵌套。

10. **列表和字符串的区别**

    列表是可变的数据类型，可以修改和添加元素。
    字符串是不可变的，一旦创建就不能修改。


11. **列表的合并**
   - 使用 `+` 运算符将两个列表合并：`list1 = [1, 2, 3]; list2 = [4, 5, 6]; combined_list = list1 + list2`
   - 使用 `extend()` 方法将一个列表的元素添加到另一个列表中：`list1.extend(list2)`

12. **列表的复制**
   - 使用 `copy()` 方法创建列表的浅拷贝：`copied_list = original_list.copy()`
   - 使用切片操作创建列表的深拷贝：`copied_list = original_list[:]`

13. **列表的排序和反排序**
   - 使用 `sort()` 方法对列表进行升序排序：`my_list.sort()`
   - 使用 `reverse()` 方法反转列表的顺序：`my_list.reverse()`
   - 使用 `sorted()` 临时排序，函数返回一个新的升序排序列表：`sorted_list = sorted(my_list)`

14. **列表的过滤**
   - 使用列表推导式过滤列表中的元素：`even_numbers = [x for x in my_list if x % 2 == 0]`
   - 使用 `filter()` 函数过滤列表中的元素：`odd_numbers = filter(lambda x: x % 2 != 0, my_list)`

15. **列表的映射**
   - 使用列表推导式将函数应用于列表中的每个元素：`squared_numbers = [x**2 for x in my_list]`
   - 使用 `map()` 函数将函数应用于列表中的每个元素：`squared_numbers = list(map(lambda x: x**2, my_list))`
16. 列表（List）和元组（Tuple）的打印技巧


17. 元组（Tuple）
- **元组是不可变的**：一旦创建，就不能修改。
- **元组的打印**：使用 `for` 循环遍历元组中的每个元素。
- **元组的切片**：无法对元组进行切片，因为元组是不可变的。
- **总结**
(1)**列表**：可变的数据类型，可以修改和添加元素。

(2)**元组**：不可变的数据类型，一旦创建就不能修改。

(3)**列表和元组的使用**：可以根据需要选择使用列表或元组。
### 2.2 条件语句
```python
if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
```
### 2.3 字典
字典是另一种可变容器模型，且可存储任意类型对象。  
字典的每个键值 key=>value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：    
d = {key1 : value1, key2 : value2, key3 : value3 }  
- 创建空字典
(1)使用大括号 { } 创建空字典：`emptyDict = {}`
(2)使用内建函数 dict() 创建字典：
`emptyDict = dict()`
- 访问字典
```python
alien_0 = {'color': 'green', 'points': 5}
new_points = alien_0['points']
```
- 添加\修改键值对
 ```python
 alien_0['x_position'] = 0
```
修改不存在的键值对会报keyError
- 删除键值对
```python
  del alien_0['points']
```
- get() 访问
```python
# get() ⽅法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不存在时要返回的值，是可选的：
alien_0 = {'color': 'green', 'speed': 'slow'}
point_value = alien_0.get('points', 'No point value assigned.')
print(point_value)
```
- 字典的遍历
```python
user_0 = {
 'username': 'efermi',
 'first': 'enrico',
 'last': 'fermi',
 }
for key, value in user_0.items():
   print(f"\nKey: {key}")
   print(f"Value: {value}")
```
-  遍历所有键
`keys()`
- 遍历所有值
`values()`
- 字典嵌套
  （1）字典列表
  （2）字典中存储列表
```
pizza = {
 'crust': 'thick',
 'toppings': ['mushrooms', 'extra cheese'],
 }
 # 概述顾客点的⽐萨
print(f"You ordered a {pizza['crust']}-crust pizza "
   "with the following toppings:")
for topping in pizza['toppings']:
   print(f"\t{topping}")
  
```
  （3）字典中存储字典
```python
 users = {
 'aeinstein': {
 'first': 'albert',
 'last': 'einstein',
 'location': 'princeton',
 },
 'mcurie': {
 'first': 'marie',
 'last': 'curie',
 'location': 'paris',
 },
 }
for username, user_info in users.items():
   print(f"\nUsername: {username}")
   full_name = f"{user_info['first']} {user_info['last']}"
   location = user_info['location']
   print(f"\tFull name: {full_name.title()}")
   print(f"\tLocation: {location.title()}")
```
### 2.4 用户输入和while 循环
- input()
默认输入是字符串，使用int() 转换成数值
- while 循环与退出
  (1)输入特定值
```python
prompt = "\nTell me something, and I will repeat it back to you:"
prompt += "\nEnter 'quit' to end the program. "
message = ""
while message != 'quit':
 message = input(prompt)
 print(message)
```
（2）使用标志
```python
prompt = "\nTell me something, and I will repeat it back to you:"
prompt += "\nEnter 'quit' to end the program. "
active = True
while active:
   message = input(prompt)
   if message == 'quit':
      active = False
   else:
      print(message)
```
(3)使用break
```python
prompt = "\nPlease enter the name of a city you have visited:"
prompt += "\n(Enter 'quit' when you are finished.) "
while True:
   city = input(prompt)
   if city == 'quit':
      break
   else:
      print(f"I'd love to go to {city.title()}!")
```
(4)使用continue
```python
current_number = 0
while current_number < 10:
   current_number += 1
   if current_number % 2 == 0:
      continue
   print(current_number)
```
### 2.5 函数
**- Python 函数定义与使用**
函数是 Python 中组织代码的基本单位，它允许我们定义可重复使用的代码块来执行特定的任务。函数通过 def 关键字来定义，后跟函数名和括号内的参数列表。函数体是缩进的代码块。
```python
def greet(name):
    """打印问候语"""
    print(f"Hello, {name}!")

greet("Alice")  # 调用函数，输出: Hello, Alice!
```
**- 返回值**
函数可以使用 return 语句来返回一个值给调用者。如果没有 return 语句，函数会默认返回 None。
```python
def add(a, b):
    """返回两个数的和"""
    return a + b

result = add(3, 4)  # 调用函数，result 的值为 7
```
**- 参数传递**
Python 中的参数传递涉及到几个概念：位置参数、关键字参数、默认参数、不定长参数。

**(1) 位置参数**
位置参数是最常见的参数类型，调用函数时按照定义的顺序传递。
```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('hamster', 'harry')  # 位置参数传递
```

**(2) 关键字参数**
关键字参数允许你在调用函数时指定参数名，这样可以不按顺序传递参数。
```python
describe_pet(pet_name='harry', animal_type='hamster')  # 关键字参数传递
```
**(3) 默认参数**
在定义函数时，可以为参数设置默认值。如果调用函数时没有提供相应的参数，则使用默认值。
```python
def describe_pet(pet_name, animal_type='dog'):
    """显示宠物的信息，默认动物类型为狗"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name='willie')  # 使用默认参数，输出: I have a dog. My dog's name is Willie.
```
**(4)不定长参数**
有时候你可能需要一个函数能够处理任意数量的参数。这些参数可以通过 *args 和 **kwargs 来接收。

*args 用于传递任意数量的位置参数，这些参数会被打包成一个元组。
**kwargs 用于传递任意数量的关键字参数，这些参数会被打包成一个字典。
```python
def make_pizza(*toppings):
    """打印顾客点的所有配料"""
    print(toppings)

make_pizza('pepperoni')  # 输出: ('pepperoni',)
make_pizza('mushrooms', 'green peppers', 'extra cheese')  # 输出: ('mushrooms', 'green peppers', 'extra cheese')
def build_profile(first, last, **user_info):
    """创建一个字典，其中包含我们知道的用户信息"""
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 'einstein', location='princeton', field='physics')
```
**参数传递的要点**
1. Python 中的参数传递是对象引用的传递，对于不可变数据类型（如整数、字符串、元组），函数内部的操作不会影响原始数据。
2. 对于可变数据类型（如列表、字典），函数内部的操作会影响原始数据。
3. 默认参数的值只在函数定义时计算一次，因此如果默认参数是一个可变数据类型，可能会引起意外的行为。
4. 使用 *args 和 **kwargs 时，函数可以接受任意数量的参数，这使得函数更加灵活，但也可能导致代码的可读性降低。
### 2.6 类

Python 是一种面向对象的编程语言。在 Python 中，几乎所有的东西都是对象，拥有属性和方法。类（Class）是用于创建对象的蓝图或原型。类定义了一组属性（称为成员变量）和方法（称为成员函数）。

1. 类的定义

类使用 `class` 关键字来定义。类名通常采用大写字母开头的驼峰命名法。类定义后跟一个冒号，然后是类的主体，一个缩进的代码块。

```python
class MyClass:
    """这是一个简单的类示例"""
    def __init__(self, name, age):
        self.name = name  # 实例变量
        self.age = age    # 实例变量

    def display(self):
        """一个成员函数，显示实例变量"""
        print(f"Name: {self.name}, Age: {self.age}")
```
2. 创建对象
创建类的实例（对象）非常简单，只需要在类名后加上括号。

```python
# 创建 MyClass 的一个对象
obj = MyClass("Alice", 30)

# 调用对象的 display 方法
obj.display()  # 输出: Name: Alice, Age: 30
```
3. 构造函数 __init__
__init__ 方法是一个特殊的方法，当创建类的新实例时会自动调用。这个方法内的 self 参数代表类的实例本身。
4. 成员变量
成员变量是类中定义的变量，用于存储每个对象的状态。成员变量通常在 __init__ 方法中通过 self 关键字来创建。
5. 成员函数
成员函数是类中定义的函数，用于对象可以执行的操作。成员函数至少有一个参数，通常是 self，代表类的实例
6. 类的方法类型
- 实例方法：第一个参数是 self，操作对象实例的属性。
- 类方法：使用 @classmethod 装饰器，第一个参数是 cls，操作类级别的属性。
- 静态方法：使用 @staticmethod 装饰器，不需要特定参数，操作类或实例的属性
```python
class MyClass:
    class_variable = "I'm a class variable"

    def __init__(self, name):
        self.name = name

    def instance_method(self):
        return f"Hello, {self.name}"

    @classmethod
    def class_method(cls):
        return f"Class variable: {cls.class_variable}"

    @staticmethod
    def static_method():
        return "I'm a static method"
```
7. 继承
继承是面向对象编程的一个主要特性。它允许我们定义一个类（子类）来继承另一个类（父类）的属性和方法。
```python
class Parent:
    def show(self):
        print("Parent method called")

class Child(Parent):
    def show(self):
        print("Child method called")

child = Child()
child.show()  # 输出: Child method called

```
8. 多态
多态是指同一个方法在不同类型的对象上执行时，表现出不同的行为。在 Python 中，多态是天然支持的。
```python
class Dog:
    def sound(self):
        return "Bark"

class Cat:
    def sound(self):
        return "Meow"

def animal_sound(animal):
    print(animal.sound())

dog = Dog()
cat = Cat()

animal_sound(dog)  # 输出: Bark
animal_sound(cat)  # 输出: Meow

```
9. 封装
封装是将数据（属性）和与数据操作相关的函数（方法）打包在一起的过程。在 Python 中，使用双下划线 __ 开头的属性或方法会被视为私有。
```python
class Car:
    def __init__(self, brand):
        self.__brand = brand  # 私有属性

    def get_brand(self):
        return self.__brand

car = Car("Tesla")
print(car.get_brand())  # 输出: Tesla
# print(car.__brand)  # 错误，无法直接访问私有属性

```
10. 导入类
1. 导入模块的某个类： from ... import ... 

```python 
from module_name import ClassName
```

2. 导入模块中的多个类：
```python 
from module_name import Class1, Class2, Class3
```
3. 导入模块中的所有类：使用 * 通配符。
```python 
from module_name import *
```
4. 导入模块中的类并重命名： as 关键字来重命名。
```python 
from module_name import ClassName as NewName
```
5. 导入模块并重命名：
```python  
import module_name as new_module_name    
```
6. 使用 import 语句导入模块：它会导入整个模块。   
```python  
import module_name
```
### 2.7 文件和异常
#### 文件操作
1. 打开文件
```python
# 打开一个文件，返回一个文件对象
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

```
2. 读取文件
```python
# 读取文件内容
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

# 逐行读取
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())

```
3. 写入文件
```python
# 写入文件内容
with open('example.txt', 'w') as file:
    file.write('Hello, world!')
```
4. 文件模式
r: 读取模式  
w: 写入模式，如果文件已存在，内容会被清空  
a: 追加模式，如果文件已存在，内容会被添加到文件末尾  
b: 二进制模式，通常用于非文本文件  
+: 更新模式，可以读取和写入文件  
5. path 模块
- 导入path 模块
```python
from pathlib import Path
```
- 创建Path 对象
```python
# 创建一个 Path 对象，可以是一个字符串路径
p = Path('example.txt')

# 或者使用当前目录下的文件
p = Path.cwd() / 'example.txt'
```
- 属性  
name: 路径的文件名   
suffix: 文件名的后缀  
stem: 文件名（不包含后缀）  
-  方法  
exists(): 检查路径是否存在  
is_file(): 检查路径是否是一个文件 
is_dir(): 检查路径是否是一个目录  
glob(): 返回与模式匹配的文件列表  
resolve(): 返回路径的绝对路径  
expanduser(): 扩展用户名占位符（如 ~） 
expandvars(): 扩展环境变量  
- 操作  
absolute(): 返回绝对路径 
relative_to(): 将路径转换为相对于另一个路径的相对路径  
joinpath(): 将多个路径片段合并为一个路径 
parent: 返回路径的父目录 
with_name(): 返回路径的副本，带有指定的文件名  
with_suffix(): 返回路径的副本，带有指定的后缀  
- 示例
```python
# 使用 Path 对象进行文件操作
p = Path('example.txt')

# 检查文件是否存在
if p.exists():
    if p.is_file():
        # 读取文件内容
        content = p.read_text()
        print(content)
    else:
        # 文件不存在或不是文件
        print('Path does not exist or is not a file.')
else:
    # 文件不存在
    print('File does not exist.')

```
#### 异常
1. 异常类型  
IOError：输入/输出错误  
ValueError：值错误  
AttributeError：属性错误  
IndexError：索引错误  
KeyError：键错误  
KeyboardInterrupt：键盘中断  
EOFError：文件结束错误  
ImportError：导入错误   
NameError：未定义名称错误   
SyntaxError：语法错误  
IndentationError：缩进错误  
TypeError：类型错误  
AssertionError：断言错误  
ZeroDivisionError：除零错误
2. 异常处理
```python
try:
    # 可能抛出异常的代码
except Exception as e:
    # 处理异常的代码
finally:
    # 无论是否抛出异常，都会执行的代码

```
3. 异常传递
当一个异常被一个 except 块捕获时，它不会被后续的 except 块捕获。

```python
try:
    # 可能抛出自定义异常的代码
except MyException as e:
    # 处理自定义异常的代码
except Exception as e:
    # 处理其他异常的代码
```

5. assert
断言是另一种检查条件的方法。当条件为 False 时，会抛出 AssertionError
```python
assert condition, message
```
### 2.8 测试
1. 基本测试方法
   - assert 
```python
# assert condition
>>> assert True     # 条件为 true 正常执行
>>> assert False    # 条件为 false 触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
>>> assert 1==1    # 条件为 true 正常执行
>>> assert 1==2    # 条件为 false 触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
 
>>> assert 1==2, '1 不等于 2'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: 1 不等于 2
>>>
```
2. pytest 
   - 测试发现：pytest 能够自动发现测试用例，只需将测试文件放在合适的目录中。
   - 断言：pytest 支持丰富的断言方法，如 assert_equal、assert_true 等
   - 测试标记（Test Markers）：使用 @pytest.mark 装饰器为测试用例添加标记，以便于分类和过滤。
   - 测试参数化（Parameterization）：pytest 支持参数化测试，允许你为测试用例提供多个输入数据。
```python
@pytest.mark.parametrize("a, b, expected", [(1, 2, 3), (3, 4, 7)])
def test_add(a, b, expected):
    assert a + b == expected
```
   -  @pytest.fixture 装饰器
  @pytest.fixture 装饰器用于定义测试中的可重用和可共享的测试数据
**参考：** https://blog.csdn.net/qq_45664055/article/details/131992948
## 3. 第三周python编程练习
### 3.1 SQLArchemy
SQLAlchemy 是一个流行的 Python SQL 工具包和对象关系映射（ORM）框架，它为开发人员提供了一种更为方便的方式来操作数据库。  

**1. 连接方式**
SQLAlchemy 支持多种数据库连接方式，最常见的是使用数据库的 URI 来连接。URI 格式通常如下：
数据库类型+数据库驱动://用户名:密码@主机名:端口/数据库名    

msql:`mysql+pymysql://username:password@localhost:3306/mydatabase'`

**2. session**   

在 SQLAlchemy 中，`Session` 是一个持久化操作对象的集合，它提供了一个事务性的上下文，用于操作数据库。通过 `Session`，你可以创建、查询、更新和删除数据库中的记录。

要使用 `Session`，首先需要创建一个 `Session` 类的实例。通常情况下，`Session` 是通过配置一个 `sessionmaker` 来创建的，`sessionmaker` 又是通过一个 `Engine` 来创建的。以下是一个简单的例子：

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# 创建数据库连接引擎
engine = create_engine('数据库URI')

# 创建一个Session工厂
Session = sessionmaker(bind=engine)

# 创建Session实例
session = Session() 
```

**3. ORM 数据模型**
SQLAlchemy ORM 通过 Python 类来表示数据库表，类属性表示表中的列。使用 Column 来定义列，使用 relationship 来定义关系。
Column 参数：
- Integer、String、Float 等：数据类型。
- primary_key：是否为主键。
- unique：是否唯一。
- index：是否建立索引。
- nullable：是否允许为空。
- default：默认值。 
Relation 详解：
relationship 用于定义表之间的关系，它可以用来表示一对多、多对一、一对一和多对多的关系。例如：
```python
 from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

class Parent(Base):
    __tablename__ = 'parents'
    id = Column(Integer, primary_key=True)
    children = relationship("Child", back_populates="parent")

class Child(Base):
    __tablename__ = 'children'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('parents.id'))
    parent = relationship("Parent", back_populates="children")
 ```
 在这个例子中，Parent 类和 Child 类通过 relationship 定义了一对多的关系。Parent 类有一个 children 属性，它关联到 Child 类的多个实例，而 Child 类有一个 parent 属性，它关联到 Parent 类的一个实例。  

**4. 操作数据库方式**
SQLAlchemy 提供了两种主要的操作数据库的方式：
使用 ORM：通过定义类和对象来操作数据库。  

```python
# 创建新对象
new_user = User(name='new_user')

# 添加到Session
session.add(new_user)

# 提交事务
session.commit()
```
使用 Core：直接使用 SQL 语句来操作数据库。  

```python
# 使用连接执行SQL语句
with engine.connect() as connection:
    result = connection.execute("SELECT * FROM users")
    for row in result:
        print(row)
```

**5. 事务操作**  

SQLAlchemy 中的事务操作是通过 Session 来管理的。当你开始一个事务时，你可以执行多个操作，然后选择提交（commit）或者回滚（rollback）。
```python
# 开始一个事务
session.begin()
try:
    # 执行数据库操作
    user = session.query(User).filter_by(name='user_to_update').first()
    user.name = 'updated_user'
    
    # 提交事务
    session.commit()
except:
    # 如果有异常，回滚事务
    session.rollback()
    raise
```

### 3.2 多线程
https://blog.csdn.net/ifhuke/article/details/128619653
### 3.3 redis
**1. python 连接方式**
下载 pip install redis
```python
import redis
# 连接到本地 Redis 服务器
r = redis.Redis(host='localhost', port=6379, db=0)
# 如果需要密码认证
# r = redis.Redis(host='localhost', port=6379, db=0, password='your_password')
```
**2. 基础数据操作方式**
```python
import redis
r = redis.Redis(host='localhost', port=6379, db=0)
#-----------字符串 -----------
# 设置键值
r.set('key', 'value')
# 获取键值
value = r.get('key')
# 自增
r.incr('counter')
# ---------------------列表 ---------------------
# 从左侧插入元素
r.lpush('mylist', 'item1')
# 从右侧插入元素
r.rpush('mylist', 'item2')
# 从左侧弹出元素
item = r.lpop('mylist')
# ---------------------集合---------------------
# 添加元素
r.sadd('myset', 'apple')
# 判断元素是否存在
exists = r.sismember('myset', 'apple')
# ---------------------hash---------------------
# 设置哈希表键值对
r.hset('user1', 'name', 'Alice')
r.hset('user1', 'age', 20)
r.hset('user1', 'gender', 'female')
# 获取整个哈希表
hash_table = r.hgetall('user1')
print(hash_table) # 输出 {b'name': b'Alice', b'age': b'20', b'gender': b'female'}
# 获取特定键对应的值
value = r.hget('user1', 'name')
print(value) # 输出 b'Alice'
# 删除哈希表的一个键值对
r.hdel('user1', 'gender')
# 获取所有键名
keys = r.hkeys('user1')
print(keys) # 输出 [b'name', b'age']
# 获取所有键名对应的值
values = r.hvals('user1')
print(values) # 输出 [b'Alice', b'20']
# 批量设置哈希表键值对
r.hmset('user2', {'name': 'Bob', 'age': 25})
# 批量获取哈希表键名对应的值
values = r.hmget('user2', ['name', 'age'])
print(values) # 输出 [b'Bob', b'25']
# ---------------------有序集合---------------------

# 添加有序集合成员和分值
r.zadd('zset1', {'foo': 1.0, 'bar': 2.0, 'baz': 4.0})
# 获取有序集合的成员数
count = r.zcard('zset1')
print(count) # 输出 3
# 获取有序集合指定范围内的成员
members = r.zrange('zset1', 0, -1)
print(members) # 输出 [b'foo', b'bar', b'baz']
# 获取有序集合指定成员的分值
score = r.zscore('zset1', 'bar')
print(score) # 输出 2.0
# 获取有序集合指定范围内成员的数量
count = r.zcount('zset1', 1.5, 3.5)
print(count) # 输出 1
# 删除有序集合中一个成员
r.zrem('zset1', 'bar')
# 获取有序集合中指定范围内的成员和分值
with_scores = r.zrangebyscore('zset1', 0, 5, withscores=True)
print(with_scores) # 输出 [(b'foo', 1.0), (b'baz', 4.0)]
```

**3. 事务和管道**
**管道：**
在Redis中，管道（pipeline）是指可以将多个Redis命令依次发送给Redis，让Redis 一次性执行这些命令并返回结果的机制。使用管道可以大大减少客户端与Redis的网络通信次数，提高Redis的处理效率，是优化Redis性能的重要手段之一。
在redis-py库中，可以使用pipeline()方法创建一个管道对象，并对该对象连续调用多个 Redis 命令并提交到 Redis 进行执行。提交执行后，每个命令都会获取到这些命令的执行结果，并按照请求的顺序返回给客户端。
- **特点：**
1.可以一次性发送多条命令并在执行完后一次性将结果返回
2.pipeline通过减少客户端与Redis的通信次数来实现降低往返延时时间
- **实现原理：**
(1) 管道pipeline实现的原理是队列，队列是先进先出，这样就保证数据的顺序性
(2) Client可以将三个命令放到一个tcp报文一起发送
(3)Server则可以将三条命令的处理结果放到一个tcp报文返回
- **基本使用**
1.使用 pipeline() 方法创建一个新的 Pipeline 对象，并向该管道对象连续调用了三个不同的 SET 命令，分别设置了三个不同的键名和对应的键值
2.通过 execute() 方法提交管道内所有的命令。Redis 服务器一次性执行管道内所有的命令，并将结果返回给客户端
3.最后输出Redis 管道执行的结果到控制台，其中包含了每个 SET 命令的执行结果
```python
trans = r.pipeline(transaction=True)
# 开启事务
trans.multi()
# 向两个键名分别设置不同的值
trans.set('foo', 'hello')
trans.set('bar', 'world')
# 在 Redis 事务中执行以上命令，并获取执行结果
result = trans.execute()
# 输出 Redis 事务执行结果
print(result)
```
**事务**
事务 Redis 通过 MULTI 和 EXEC 来实现事务，MULTI 开启一个事务，EXEC 提交多个命令到 Redis 执行，可以保证单位时间内只有当前请求在访问 Redis 服务器，其他读写操作会等待这个事务结束后才能进行，从而保证了数据一致性。
- **基本使用**
1.创建一个 redis.StrictRedis 实例，并且设置 transaction 参数为 True，表示开启 Redis 事务
2.使用 pipeline() 方法创建一个新的 Pipeline 对象，并将其 transaction 参数设置为 True，表示这个 Pipeline 是用于 Redis 事务的
3.调用 multi() 方法开启Redis 事务，之后向两个不同的键名 foo 和 bar 分别设置了不同的字符串值
4.最后通过 execute() 方法提交事务，Redis 将一次性执行整个事务并返回每个命令的执行结果
```python
# 使用 Redis 事务
trans = r.pipeline(transaction=True)
# 开启事务
trans.multi()
# 向两个键名分别设置不同的值
trans.set('foo', 'hello')
trans.set('bar', 'world')
# 在 Redis 事务中执行以上命令，并获取执行结果
result = trans.execute()
# 输出 Redis 事务执行结果
print(result)
```
 **区别**
在Redis中，事务（transaction）和管道（pipeline）都是用于批量执行命令的方式，但二者有本质上的不同：

1.调用方式不同

使用事务时，需要先通过MULTI命令将客户端设置为事务模式，然后按照一定的顺序添加执行的多个命令，最后通过EXEC命令将操作提交到服务器执行。

使用管道时，则是对同一个连接对象上连续调用多个Redis命令并且在最后统一执行这些命令。

2.发送机制不同

Redis事务的逻辑单元可以确保所有被包含的命令“原子性”地执行，即要么全部执行成功完成，要么全部回滚；而Redis>运用管道的方法仅仅是优化传输，将多个命令打包发送到Redis服务节点，并在结果关闭时进行收集处理，以达到多个请求一次通信的目的。

3.回滚能力不同
Redis事务提交的过程中如果某个命令执行失败了，后面的命令则都不会再执行，已经执行过的命令不会回滚。当然在EXEC之前可以通过DISCARD命令清空已经放入到事务队列里面的命令；而管道机制暂时没有回滚的能力。